<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/course-101-0250-00/libs/katex/katex.min.css"> <link rel=stylesheet  href="/course-101-0250-00/libs/highlight/github.min.css"> <link rel=stylesheet  href="/course-101-0250-00/css/franklin.css"> <link rel=stylesheet  href="/course-101-0250-00/css/poole_hyde.css"> <link rel=stylesheet  href="/course-101-0250-00/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/course-101-0250-00/assets/favicon.png"> <title>Lecture 8</title> <style> .content {max-width: 50rem} </style> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <img src="/course-101-0250-00/assets/vaw_logo.png" style="width: 180px; height: auto; display: inline"> <div style="font-weight: margin-bottom: 0.5em"><a href="/course-101-0250-00/"> Fall 2021</a> <span style="opacity: 0.7;">| <a href="http://www.vvz.ethz.ch/Vorlesungsverzeichnis/lerneinheit.view?semkez=2021W&ansicht=KATALOGDATEN&lerneinheitId=155538&lang=en"> ETHZ 101-0250-00</a></span></div> <br> <h1><a href="/course-101-0250-00/">Solving partial differential equations in parallel on GPUs</a></h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by <a href="https://vaw.ethz.ch/en/people/person-detail.MjcwOTYw.TGlzdC8xOTYxLDE1MTczNjI1ODA=.html">Ludovic Räss</a>, <a href="https://vaw.ethz.ch/en/personen/person-detail.html?persid=124402">Mauro Werder</a> & <a href="https://www.cscs.ch/about/staff/">Samuel Omlin</a> </div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9"> <a class="sidebar-nav-item " href="/course-101-0250-00/"><b>Welcome</b></a> <a class="sidebar-nav-item " href="/course-101-0250-00/logistics/">Logistics</a> <a class="sidebar-nav-item " href="/course-101-0250-00/homework/">Homework</a> <a class="sidebar-nav-item " href="/course-101-0250-00/software_install/">Software install</a> <a class="sidebar-nav-item " href="/course-101-0250-00/extras/">Extras</a> <br> <div class=course-section >Part 1 - Introduction</div> <a class="sidebar-nav-item " href="/course-101-0250-00/lecture1/">Lecture 1</a> <a class="sidebar-nav-item " href="/course-101-0250-00/lecture2/">Lecture 2</a> <a class="sidebar-nav-item " href="/course-101-0250-00/lecture3/">Lecture 3</a> <a class="sidebar-nav-item " href="/course-101-0250-00/lecture4/">Lecture 4</a> <div class=course-section >Part 2 - Solving PDEs on GPUs</div> <a class="sidebar-nav-item " href="/course-101-0250-00/lecture5/">Lecture 5</a> <a class="sidebar-nav-item " href="/course-101-0250-00/lecture6/">Lecture 6</a> <a class="sidebar-nav-item " href="/course-101-0250-00/lecture7/">Lecture 7</a> <a class="sidebar-nav-item active" href="/course-101-0250-00/lecture8/">Lecture 8</a> <div class=course-section >Part 3 - Projects</div> <br> </nav> </div> </div> <div class="content container"> <div class=franklin-content > <h1 id=lecture_8 ><a href="#lecture_8" class=header-anchor >Lecture 8</a></h1> <blockquote> <p><strong>Agenda</strong><br />📚 Distributed multi-XPU computing, MPI, Stokes flow<br />💻 Automatic documentation &#40;<code>Documenter.jl</code>,<code>Literate.jl</code>&#41;<br />🚧 Exercises:</p> <ul> <li><p>Fake parallelisation, Julia MPI, <code>ImplicitGlobalGrid.jl</code></p> <li><p>Fluid dynamics: Navier-Stokes equations, incompressible Stokes flow </p> <li><p>Automatic documentation and CI</p> </ul> </blockquote> <hr /> <p><a id=content  class=anchor ></a> <strong>Content</strong></p> <div class=franklin-toc ><ol><li><a href="#lecture_8">Lecture 8</a><li><a href="#distributed_computing_in_julia">Distributed computing in Julia</a><ol><li><a href="#new_to_distributed_computing">New to distributed computing?</a><li><a href="#fake_parallelisation">Fake parallelisation</a><li><a href="#julia_and_mpi">Julia and MPI</a><li><a href="#using_implicitglobalgridjl">Using <code>ImplicitGlobalGrid.jl</code></a></ol><li><a href="#towards_stokes_ii_viscous_stokes_flow">Towards Stokes II: viscous Stokes flow</a><li><a href="#automatic_documentation_in_julia">Automatic documentation in Julia</a><li><a href="#exercises_-_lecture_8">Exercises - lecture 8</a></ol></div> <p><a href="#exercises_-_lecture_8"><em>👉 get started with exercises</em></a></p> <hr /> <h1 id=distributed_computing_in_julia ><a href="#distributed_computing_in_julia" class=header-anchor >Distributed computing in Julia</a></h1> <h3 id=the_goal_of_this_lecture_8 ><a href="#the_goal_of_this_lecture_8" class=header-anchor >The goal of this lecture 8:</a></h3> <ul> <li><p>Distributed computing</p> <ul> <li><p>Fake parallelisation</p> <li><p>Julia MPI &#40;CPU &#43; GPU&#41;</p> <li><p>Using <code>ParallelStencil.jl</code> together with <code>ImplicitGlobalGrid.jl</code></p> </ul> <li><p>Towards Stokes II: elastic to viscous &#40;Cauchy-Navier to &#40;Navier-&#41;Stokes&#41;</p> <li><p>Automatic documentation and CI</p> </ul> <h2 id=new_to_distributed_computing ><a href="#new_to_distributed_computing" class=header-anchor >New to distributed computing?</a></h2> <p><em>If this is the case or not - hold-on, we certainly have some good stuff for everyone</em></p> <h3 id=distributed_computing ><a href="#distributed_computing" class=header-anchor >Distributed computing</a></h3> <p>Adds one additional layer of parallelisation:</p> <ul> <li><p>Global problem does no longer &quot;fit&quot; within a single compute node &#40;or GPU&#41;</p> <li><p>Local resources &#40;mainly memory&#41; are finite, e.g.,</p> <ul> <li><p>CPUs: increase the number of cores beyond what a single CPU can offer</p> <li><p>GPUs: overcome the device memory limitation</p> </ul> </ul> <p>Simply said:</p> <p><em>If one compute device is not sufficient to solve a problem, duplicate the resource and solve a subset of the global problem on each.</em></p> <p>Distributed &#40;memory&#41; computing permits to take advantage of computing &quot;cluster&quot;, many similar compute nodes interconnected by high-throughput network. That&#39;s also what supercomputers are.</p> <h3 id=parallel_scaling ><a href="#parallel_scaling" class=header-anchor >Parallel scaling</a></h3> <p>So here we go. Let&#39;s assume we want to solve a global problem. This global problem can be split into several local problems that execute concurrently.</p> <p>Two scaling approaches exist:</p> <ul> <li><p>strong scaling</p> <li><p>weak scaling</p> </ul> <p>Increasing the amount of computing resources to resolve the same global problem would increase parallelism and may result in faster execution &#40;wall-time&#41;. This parallelisation is called <em><strong>strong scaling</strong></em>; the resources are increased but the global problem size does not change, resulting in an increase in the number of &#40;smaller&#41; local problems that can be solved in parallel.</p> <p>This <em><strong>strong scaling</strong></em> approach is mostly used when parallelising existing CPU codes as increasing the number of parallel local problems would lead to some speed-up, reaching an optimum beyond which additional local processes would no longer be beneficial.</p> <p>However, we won&#39;t follow that path for parallel multi-GPU computing. Why?</p> <p><em>Because GPUs&#39; performance is very sensitive to the local problem size as we experienced when trying to tune the kernel launch parameters &#40;threads, blocks, i.e., the local problem size&#41;.</em></p> <p>With GPUs, it is better suited to approach distributed parallelisation from a <em><strong>weak scaling</strong></em> perspective; defining first the optimal local problem size to resolve on a single GPU and then increasing the number of optimal local problems &#40;and the number of GPUs&#41; until reaching the global problem one originally wants to solve.</p> <h3 id=implicit_global_grid ><a href="#implicit_global_grid" class=header-anchor >Implicit Global Grid</a></h3> <p>We can thus use a local problem and duplicate it in the Cartesian space to obtain a global grid, which is thus defined implicitly. Local problems exchange internal boundary conditions &#40;to synchronise&#41; using intra-node communication &#40;e.g., message passing interface - <a href="https://en.wikipedia.org/wiki/Message_Passing_Interface">MPI</a>&#41;, as depicted on the <a href="https://github.com/eth-cscs/ImplicitGlobalGrid.jl">figure</a> hereafter:</p> <p><img src="../assets/literate_figures/l8-igg.png" alt=IGG  /></p> <h3 id=distributing_computations_-_challenges ><a href="#distributing_computations_-_challenges" class=header-anchor >Distributing computations - challenges</a></h3> <p>Many things could certainly go wrong in distributed computing. However, the ultimate goal &#40;at least for us&#41; is to keep up with <em><strong>parallel efficiency</strong></em>.</p> <p>The parallel efficiency defines the ratio between the execution time of an n-fold larger problem divided by the execution time of a single process to perform a given number of iterations.</p> <p>Ideally, the parallel efficiency should stay close to 1 while increasing the number of computing resources, meaning no time is lost &#40;no overhead&#41; in communication &#40;due to e.g., global reduction, inter-process communication, congestion of shared filesystem, etc...&#41; as shown in the <a href="https://github.com/eth-cscs/ImplicitGlobalGrid.jl">figure</a> hereafter:</p> <p><img src="../assets/literate_figures/l8-par_eff.png" alt="Parallel scaling" /></p> <hr /> <h3 id=lets_get_started ><a href="#lets_get_started" class=header-anchor >Let&#39;s get started</a></h3> <p>we will explore distributed computing with Julia&#39;s MPI wrapper MPI.jl. This will enable our codes to run on multiple CPUs and GPUs in order to scale on modern multi-CPU/GPU nodes, clusters and supercomputers. In the proposed approach, each MPI process handles one CPU or GPU.</p> <p>We&#39;re going to work out the following steps to tackle distributed parallelisation in this lecture &#40;in 5 tasks&#41;:</p> <ul> <li><p><a href="#fake_parallelisation"><strong>Fake parallelisation</strong> as proof-of-concept</a></p> <li><p><a href="#julia_and_mpi"><strong>Julia and MPI</strong></a></p> </ul> <h2 id=fake_parallelisation ><a href="#fake_parallelisation" class=header-anchor >Fake parallelisation</a></h2> <p>As a first step, we will look at the below 1-D diffusion code which solves the linear diffusion equations using a &quot;fake-parallelisation&quot; approach. We split the calculation on two distinct left and right domains, which requires left and right <code>C</code> arrays, <code>CL</code> and <code>CR</code>, respectively.</p> <p>In this &quot;fake parallelization&quot; code, the computations for the left and right domain are performed sequentially on one process, but they could be computed on two distinct processes if the needed boundary update &#40;often referred to as halo update in literature&#41; was done with MPI.</p> <p>The idea of this fake parallelization approach is the following:</p> <pre><code class="julia hljs"><span class=hljs-comment ># Compute physics locally</span>
CL[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>] .= CL[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>] .+ dt*D*diff(diff(CL)/dx)/dx
CR[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>] .= CR[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>] .+ dt*D*diff(diff(CR)/dx)/dx
<span class=hljs-comment ># Update boundaries (MPI)</span>
CL[<span class=hljs-keyword >end</span>] = ...
CR[<span class=hljs-number >1</span>]   = ...
<span class=hljs-comment ># Global picture</span>
C .= [CL[<span class=hljs-number >1</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>]; CR[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>]]</code></pre> <p>We see that a correct boundary update will be the critical part for a successful implementation. In our approach, we need an overlap of 2 cells between <code>CL</code> and <code>CR</code> in order to avoid any wrong computations at the transition between the left and right domains.</p> <h3 id=task_1_fake_parallelisation_with_2_fake_processes ><a href="#task_1_fake_parallelisation_with_2_fake_processes" class=header-anchor >Task 1 &#40;fake parallelisation with 2 fake processes&#41;</a></h3> <p>Run the &quot;fake parallelisation&quot; 1-D diffusion code <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/diffusion_1D_2procs.jl"><code>diffusion_1D_2procs.jl</code></a> &#40;also available in your <code>/scratch/&lt;username&gt;/lecture08</code> directory on <code>octopus</code>&#41;, which is missing the boundary updates of the 2 fake processes and describe what you see in the visualisation.</p> <p>Then, add the required boundary update:</p> <pre><code class="julia hljs"><span class=hljs-comment ># Update boundaries (MPI)</span>
CL[<span class=hljs-keyword >end</span>] = ...
CR[<span class=hljs-number >1</span>]   = ...</code></pre> <p>in order make the code work properly and run it again. Note what has changed in the visualisation.</p> <p>The next step will be to generalise the fake parallelisation with <code>2</code> fake processes to work with <code>n</code> fake processes. The idea of this generalized fake parallelization approach is the following:</p> <pre><code class="julia hljs"><span class=hljs-keyword >for</span> ip = <span class=hljs-number >1</span>:np <span class=hljs-comment ># compute physics locally</span>
    C[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,ip] .= C[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,ip] .+ dt*D*diff(diff(C[:,ip])/dxg)/dxg
<span class=hljs-keyword >end</span>
<span class=hljs-keyword >for</span> ip = <span class=hljs-number >1</span>:np-<span class=hljs-number >1</span> <span class=hljs-comment ># update boundaries</span>
   <span class=hljs-comment ># ...</span>
<span class=hljs-keyword >end</span>
<span class=hljs-keyword >for</span> ip = <span class=hljs-number >1</span>:np <span class=hljs-comment ># global picture</span>
    i1 = <span class=hljs-number >1</span> + (ip-<span class=hljs-number >1</span>)*(nx-<span class=hljs-number >2</span>)
    Cg[i1:i1+nx-<span class=hljs-number >2</span>] .= C[<span class=hljs-number >1</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,ip]
<span class=hljs-keyword >end</span></code></pre> <p>The array <code>C</code> contains now <code>n</code> local domains where each domain belongs to one fake process, namely the fake process indicated by the second index of <code>C</code> &#40;ip&#41;. The boundary updates are to be adapted accordingly. All the physical calculations happen on the local chunks of the arrays. We only need &quot;global&quot; knowledge in the definition of the initial condition.</p> <p>The previous simple initial conditions can be easily defined without computing any Cartesian coordinates. To define other initial conditions we often need to compute global coordinates. In the code below, which serves to define a Gaussian anomaly in the centre of the domain, Cartesian coordinates can be computed for each cell based on the process ID &#40;<code>ip</code>&#41;, the cell ID &#40;<code>ix</code>&#41;, the array size &#40;<code>nx</code>&#41;, the overlap of the local domains &#40;<code>2</code>&#41; and the grid spacing of the global grid &#40;<code>dxg</code>&#41;; moreover, the origin of the coordinate system can be moved to any position using the global domain length &#40;<code>lx</code>&#41;:</p> <pre><code class="julia hljs"><span class=hljs-comment ># Initial condition</span>
<span class=hljs-keyword >for</span> ip = <span class=hljs-number >1</span>:np
    <span class=hljs-keyword >for</span> ix = <span class=hljs-number >1</span>:nx
        x[ix,ip] = ...
        C[ix,ip] = exp(-x[ix,ip]^<span class=hljs-number >2</span>)
    <span class=hljs-keyword >end</span>
    i1 = <span class=hljs-number >1</span> + (ip-<span class=hljs-number >1</span>)*(nx-<span class=hljs-number >2</span>)
    xt[i1:i1+nx-<span class=hljs-number >2</span>] .= x[<span class=hljs-number >1</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,ip]; <span class=hljs-keyword >if</span> (ip==np) xt[i1+nx-<span class=hljs-number >1</span>] = x[<span class=hljs-keyword >end</span>,ip] <span class=hljs-keyword >end</span>
    Ct[i1:i1+nx-<span class=hljs-number >2</span>] .= C[<span class=hljs-number >1</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,ip]; <span class=hljs-keyword >if</span> (ip==np) Ct[i1+nx-<span class=hljs-number >1</span>] = C[<span class=hljs-keyword >end</span>,ip] <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre> <h3 id=task_2_fake_parallelisation_with_n_fake_processes ><a href="#task_2_fake_parallelisation_with_n_fake_processes" class=header-anchor >Task 2 &#40;fake parallelisation with <code>n</code> fake processes&#41;</a></h3> <p>Modify the initial condition in the 1-D diffusion code <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/diffusion_1D_nprocs.jl"><code>diffusion_1D_nprocs.jl</code></a> &#40;also available in your <code>/scratch/&lt;username&gt;/lecture08</code> directory on <code>octopus</code>&#41; to a centred <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><msub><mi>L</mi><mi>x</mi></msub><mi mathvariant=normal >/</mi><mn>2</mn><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(L_x/2)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">L</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mord >/</span><span class=mord >2</span><span class=mclose >)</span></span></span></span> Gaussian anomaly.</p> <p>Then run this code which is missing the boundary updates of the <code>n</code> fake processes and describe what you see in the visualisation. Then, add the required boundary update in order make the code work properly and run it again. Note what has changed in the visualisation.</p> <h2 id=julia_and_mpi ><a href="#julia_and_mpi" class=header-anchor >Julia and MPI</a></h2> <p>We are now ready to write a code that will truly distribute calculations on different processors using <a href="https://github.com/JuliaParallel/MPI.jl">MPI.jl</a> for inter-process communication.</p> <div class=note ><div class=title >💡 Note</div> <div class=messg >At this point, make sure to have a working Julia MPI environment. Head to <a href="/course-101-0250-00/software_install/#julia_mpi">Julia MPI install</a> to set-up Julia MPI. See <a href="/course-101-0250-00/software_install/#julia_mpi_gpu_on_your_octopus_node">Julia MPI GPU on your <code>octopus</code> node</a> for detailed information on how to run MPI GPU &#40;multi-GPU&#41; applications on your assigned <code>octopus</code> node.</div></div> <p>Let us see what are the somewhat minimal requirements that will allow us to write a distributed code in Julia using MPI.jl. We will solve the following linear diffusion physics:</p> <pre><code class="julia hljs"><span class=hljs-keyword >for</span> it = <span class=hljs-number >1</span>:nt
    qx         .= .-D*diff(C)/dx
    C[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>] .= C[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>] .- dt*diff(qx)/dx
<span class=hljs-keyword >end</span></code></pre> <p>To enable distributed parallelisation, we will do the following steps:</p> <ol> <li><p>Initialise MPI and set up a Cartesian communicator</p> <li><p>Implement a boundary exchange routine</p> <li><p>Create a &quot;global&quot; initial condition</p> <li><p>Finalise MPI</p> </ol> <p>To &#40;1.&#41; initialise MPI and prepare the Cartesian communicator, we do:</p> <pre><code class="julia hljs">MPI.Init()
dims        = [<span class=hljs-number >0</span>]
comm        = MPI.COMM_WORLD
nprocs      = MPI.Comm_size(comm)
MPI.Dims_create!(nprocs, dims)
comm_cart   = MPI.Cart_create(comm, dims, [<span class=hljs-number >0</span>], <span class=hljs-number >1</span>)
me          = MPI.Comm_rank(comm_cart)
coords      = MPI.Cart_coords(comm_cart)
neighbors_x = MPI.Cart_shift(comm_cart, <span class=hljs-number >0</span>, <span class=hljs-number >1</span>)</code></pre> <p>where <code>me</code> represents the process ID unique to each MPI process &#40;the analogue to <code>ip</code> in the fake parallelisation&#41;.</p> <p>Then, we need to &#40;2.&#41; implement a boundary update routine, which can have the following structure:</p> <pre><code class="julia hljs"><span class=hljs-meta >@views</span> <span class=hljs-keyword >function</span> update_halo(A, neighbors_x, comm)
    <span class=hljs-comment ># Send to / receive from neighbor 1 (&quot;left neighbor&quot;)</span>
    <span class=hljs-keyword >if</span> neighbors_x[<span class=hljs-number >1</span>] != MPI.MPI_PROC_NULL
        <span class=hljs-comment ># ...</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-comment ># Send to / receive from neighbor 2 (&quot;right neighbor&quot;)</span>
    <span class=hljs-keyword >if</span> neighbors_x[<span class=hljs-number >2</span>] != MPI.MPI_PROC_NULL
        <span class=hljs-comment ># ...</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span>
<span class=hljs-keyword >end</span></code></pre> <p>Then, we &#40;3.&#41; initialize <code>C</code> with a &quot;global&quot; initial Gaussian anomaly that spans correctly over all local domains. This can be achieved, e.g., as given here:</p> <pre><code class="julia hljs">x0    = coords[<span class=hljs-number >1</span>]*(nx-<span class=hljs-number >2</span>)*dx
xc    = [x0 + ix*dx - dx/<span class=hljs-number >2</span> - <span class=hljs-number >0.5</span>*lx  <span class=hljs-keyword >for</span> ix=<span class=hljs-number >1</span>:nx]
C     = exp.(.-xc.^<span class=hljs-number >2</span>)</code></pre> <p>where <code>x0</code> represents the first global x-coordinate on every process &#40;computed in function of <code>coords</code>&#41; and <code>xc</code> represents the local chunk of the global coordinates on each local process &#40;this is analogue to the initialisation in the fake parallelization&#41;.</p> <p>Last, we need to &#40;4.&#41; finalise MPI prior to returning from the main function:</p> <pre><code class="julia hljs">MPI.Finalize()</code></pre>
<p>All the above described is found in the code <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/diffusion_1D_mpi.jl"><code>diffusion_1D_mpi.jl</code></a> &#40;also available in your <code>/scratch/&lt;username&gt;/lecture08</code> directory on <code>octopus</code>&#41;, except for the boundary updates &#40;see 2.&#41;.</p>
<h3 id=task_3_1-d_parallelisation_with_mpi ><a href="#task_3_1-d_parallelisation_with_mpi" class=header-anchor >Task 3 &#40;1-D parallelisation with MPI&#41;</a></h3>
<p>Run the code <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/diffusion_1D_mpi.jl"><code>diffusion_1D_mpi.jl</code></a> which is still missing the boundary updates three times: with 1, 2 and 4 processes &#40;replacing <code>np</code> by the number of processes and <code>&lt;username&gt;</code> with your username on <code>octopus</code>&#41;:</p>
<pre><code class="sh hljs">/home/&lt;username&gt;/.julia/bin/mpiexecjl -n np julia --project &lt;my_script.jl&gt;</code></pre>
<p>Visualise the results after each run with the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/vizme1D_mpi.jl"><code>vizme1D_mpi.jl</code></a> code &#40;adapt the variable <code>nprocs</code>&#33;&#41;. Describe what you see in the visualisation. Then, add the required boundary update in order make the code work properly and run it again. Note what has changed in the visualisation.</p>
<div class=note ><div class=title >💡 Note</div>
<div class=messg >For the boundary updates, you can use the following approach for the communication with each neighbor: 1&#41; create a sendbuffer and receive buffer, storing the right value in the send buffer; 2&#41; use <code>MPI.Send</code> and <code>MPI.Recv&#33;</code> to send/receive the data; 3&#41; store the received data in the right position in the Array.</div></div>
<p>Congratulations&#33; You just did a distributed diffusion solver in only 70 lines of code.</p>
<p>Let us now do the same in 2D: there is not much new there, but it may be interesting to work out how boundary update routines can be defined in 2D as one now needs to exchange vectors instead of single values.</p>
<h3 id=task_4_2-d_parallelisation_with_mpi ><a href="#task_4_2-d_parallelisation_with_mpi" class=header-anchor >Task 4 &#40;2-D parallelisation with MPI&#41;</a></h3>
<p>Run the code <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/diffusion_2D_mpi.jl"><code>diffusion_2D_mpi.jl</code></a> which is still missing the boundary updates three times: with 1, 2 and 4 processes.</p>
<p>Visualise the results after each run with the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/vizme2D_mpi.jl"><code>vizme2D_mpi.jl</code></a> code &#40;adapt the variable <code>nprocs</code>&#33;&#41;. Describe what you see in the visualisation. Then, add the required boundary update in order make the code work properly and run it again. Note what has changed in the visualisation.</p>
<p>The last step is to create a multi-GPU solver out of the above multi-CPU solver. CUDA-aware MPI is of great help in this task, because it allows to directly pass GPU arrays to the MPI functions.</p>
<p>Besides facilitating the programming, it can leverage Remote Direct Memory Access &#40;RDMA&#41; which can be of great benefit in many HPC scenarios.</p>
<h3 id=task_5_multi-gpu_homework ><a href="#task_5_multi-gpu_homework" class=header-anchor >Task 5 &#40;multi-GPU&#41; <strong>HOMEWORK</strong></a></h3>
<p>Translate the code <code>diffusion_2D_mpi.jl</code> from Task 4 to GPU using GPU array programming. Note what changes were needed to go from CPU to GPU in this distributed solver.</p>
<div class=note ><div class=title >💡 Note</div>
<div class=messg >You can use a similar approach as in the CPU code to perform the boundary updates. You can use <code>copyto&#33;</code> function in order to copy the data from the GPU memory into the send buffers &#40;CPU memory&#41; or to copy the receive buffer data to the GPU array.</div></div>
<div class=note ><div class=title >💡 Note</div>
<div class=messg >As alternative, one could use the same approach as in the CPU code to perform the boundary updates thanks to CUDA-aware MPI &#40;it allows to pass GPU arrays directly to the MPI functions&#41;. However, this requires MPI being specifically compiled against a CUDA installation.</div></div>
<p>This completes the introduction to distributed parallelisation with Julia.</p>
<p>Note that high-level Julia packages as for example <a href="https://github.com/eth-cscs/ImplicitGlobalGrid.jl">ImplicitGlobalGrid.jl</a> can render distributed parallelisation with GPU and CPU for HPC a very simple task.</p>
<p>Let&#39;s check it out&#33;</p>
<h2 id=using_implicitglobalgridjl ><a href="#using_implicitglobalgridjl" class=header-anchor >Using <code>ImplicitGlobalGrid.jl</code></a></h2>
<p>Let&#39;s have look at <a href="https://github.com/eth-cscs/ImplicitGlobalGrid.jl">ImplicitGlobalGrid.jl</a>&#39;s repository.</p>
<p>ImplicitGlobalGrid.jl can render distributed parallelisation with GPU and CPU for HPC a very simple task. Moreover, ImplicitGlobalGrid.jl elegantly combines with <a href="https://github.com/omlins/ParallelStencil.jl">ParallelStencil.jl</a>.</p>
<p>Finally, the cool bit: using both packages together enables to <a href="https://github.com/omlins/ParallelStencil.jl#seamless-interoperability-with-communication-packages-and-hiding-communication">hide communication behind computation</a>. This feature enables a parallel efficiency close to 1.</p>
<p>For this demo, we&#39;ll start from the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/diffusion_2D_perf_xpu.jl"><code>diffusion_2D_perf_xpu.jl</code></a> code &#40;also available in your <code>/scratch/&lt;username&gt;/lecture08</code> directory on <code>octopus</code>&#41;.</p>
<p>Only a few changes are required to enable multi-XPU execution, namely:</p>
<ol>
<li><p>initialise the implicit global grid</p>

<li><p>use global coordinates to compute the initial condition</p>

<li><p>update halo &#40;and overlap communication with computation&#41;</p>

<li><p>finalise the global grid</p>

<li><p>tune visualisation</p>

</ol>
<p>To &#40;1.&#41; initialise the global grid, one first needs to use the package and import MPI</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> ImplicitGlobalGrid
<span class=hljs-keyword >import</span> MPI</code></pre>
<p>Then, one can add the global grid initialisation in the <code># Derived numerics</code> section</p>
<pre><code class="julia hljs">me, dims = init_global_grid(nx, ny, <span class=hljs-number >1</span>)  <span class=hljs-comment ># Initialization of MPI and more...</span>
<span class=hljs-meta >@static</span> <span class=hljs-keyword >if</span> USE_GPU select_device() <span class=hljs-keyword >end</span>  <span class=hljs-comment ># select one GPU per MPI local rank (if &gt;1 GPU per node)</span>
dx, dy  = Lx/nx_g(), Ly/ny_g()</code></pre>
<p>Note that we include the <code>select_device&#40;&#41;</code> function to map each MPI process to a unique GPU on the node.</p>
<div class=note ><div class=title >💡 Note</div>
<div class=messg >Have a look at the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/hello_mpi_gpu.jl"><code>hello_mpi_gpu.jl</code></a> code to get an idea on how to select unique GPU using node-local MPI infos.</div></div>
<p>Then, for &#40;2.&#41;, one can use <code>x_g&#40;&#41;</code> and <code>y_g&#40;&#41;</code> to compute the global coordinates in the initialisation &#40;to correctly spread the Gaussian distribution over all local processes&#41;</p>
<pre><code class="julia hljs">C       = <span class=hljs-meta >@zeros</span>(nx,ny)
C      .= Data.<span class=hljs-built_in >Array</span>([exp(-(x_g(ix,dx,C)+dx/<span class=hljs-number >2</span> -Lx/<span class=hljs-number >2</span>)^<span class=hljs-number >2</span> -(y_g(iy,dy,C)+dy/<span class=hljs-number >2</span> -Ly/<span class=hljs-number >2</span>)^<span class=hljs-number >2</span>) <span class=hljs-keyword >for</span> ix=<span class=hljs-number >1</span>:size(C,<span class=hljs-number >1</span>), iy=<span class=hljs-number >1</span>:size(C,<span class=hljs-number >2</span>)])</code></pre>
<p>The halo update &#40;3.&#41; can be simply performed adding following line after the <code>compute&#33;</code> kernel</p>
<pre><code class="julia hljs">update_halo!(C)</code></pre>
<p>Now, when running on GPUs, it is possible to hide MPi communication behind computations&#33; This option implements as:</p>
<pre><code class="julia hljs"><span class=hljs-meta >@hide_communication</span> (<span class=hljs-number >8</span>, <span class=hljs-number >2</span>, <span class=hljs-number >0</span>) <span class=hljs-keyword >begin</span>
    <span class=hljs-meta >@parallel</span> compute!(C2, C, D_dx, D_dy, dt, _dx, _dy, size_C1_2, size_C2_2)
    C, C2 = C2, C <span class=hljs-comment ># pointer swap</span>
    update_halo!(C)
<span class=hljs-keyword >end</span></code></pre>
<p>The <code>@hide_communication &#40;8, 2, 0&#41;</code> will first compute the first and last 8 and 2 grid points in x and y dimension, respectively. Then, while exchanging boundaries the rest of the local domains computations will be perform &#40;overlapping the MPI communication&#41;.</p>
<p>To &#40;4.&#41; finalise the global grid,</p>
<pre><code class="julia hljs">finalize_global_grid()</code></pre>
<p>needs to be added before the <code>return</code> of the &quot;main&quot;.</p>
<p>The last changes to take car of is to &#40;5.&#41; handle visualisation in an appropriate fashion. Here, several options exists.</p>
<ul>
<li><p>One approach would for each local process to dump the local domain results to a file &#40;with process ID in the filename&#41; in order to reconstruct to global grid with a post-processing visualisation script &#40;as done in the previous examples&#41;.</p>

<li><p>Another approach would be to gather the global grid results on a master process before doing further steps as disk saving or plotting.</p>

</ul>
<p>To implement the latter, one needs to define global array for visualisation:</p>
<pre><code class="julia hljs">nx_v, ny_v = (nx-<span class=hljs-number >2</span>)*dims[<span class=hljs-number >1</span>], (ny-<span class=hljs-number >2</span>)*dims[<span class=hljs-number >2</span>]
<span class=hljs-keyword >if</span> (nx_v*ny_v*sizeof(Data.<span class=hljs-built_in >Number</span>) &gt; <span class=hljs-number >0.8</span>*Sys.free_memory()) error(<span class=hljs-string >&quot;Not enough memory for visualization.&quot;</span>) <span class=hljs-keyword >end</span>
C_v   = zeros(nx_v, ny_v) <span class=hljs-comment ># global array for visu</span>
C_inn = zeros(nx-<span class=hljs-number >2</span>, ny-<span class=hljs-number >2</span>) <span class=hljs-comment ># no halo local array for visu</span>
Xi_g, Yi_g = <span class=hljs-built_in >LinRange</span>(dx+dx/<span class=hljs-number >2</span>, Lx-dx-dx/<span class=hljs-number >2</span>, nx_v), <span class=hljs-built_in >LinRange</span>(dy+dy/<span class=hljs-number >2</span>, Ly-dy-dy/<span class=hljs-number >2</span>, ny_v) <span class=hljs-comment ># inner points only</span></code></pre>
<p>Then, the plotting routine can be adapted to first gather the inner points of the local domains into the global array &#40;using <code>gather&#33;</code> function&#41; and then plot and/or save the global array &#40;here <code>C_v</code>&#41; from the master process <code>me&#61;&#61;0</code>:</p>
<pre><code class="julia hljs">C_inn .= C[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>]; gather!(C_inn, C_v)
<span class=hljs-keyword >if</span> (me==<span class=hljs-number >0</span>)
    opts = (aspect_ratio=<span class=hljs-number >1</span>, xlims=(Xi_g[<span class=hljs-number >1</span>], Xi_g[<span class=hljs-keyword >end</span>]), ylims=(Yi_g[<span class=hljs-number >1</span>], Yi_g[<span class=hljs-keyword >end</span>]), clims=(<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>), c=:davos, xlabel=<span class=hljs-string >&quot;Lx&quot;</span>, ylabel=<span class=hljs-string >&quot;Ly&quot;</span>, title=<span class=hljs-string >&quot;time = <span class=hljs-subst >$(round(it*dt, sigdigits=<span class=hljs-number >3</span>)</span>)&quot;</span>)
    heatmap(Xi_g, Yi_g, <span class=hljs-built_in >Array</span>(C_v)&#x27;; opts...); frame(anim)
<span class=hljs-keyword >end</span></code></pre>
<div class=note ><div class=title >💡 Note</div>
<div class=messg >We here did not rely on CUDA-aware MPI. However, we can use this feature in the final projects. Note that the examples using ImplicitGlobalGrid.jl would also work if <code>USE_GPU &#61; false</code>; however, the communication and computation overlap feature is then not available as its implementation relies on leveraging CUDA streams.</div></div>
<h1 id=towards_stokes_ii_viscous_stokes_flow ><a href="#towards_stokes_ii_viscous_stokes_flow" class=header-anchor >Towards Stokes II: viscous Stokes flow</a></h1>
<p>Transforming the Cauchy-Navier elastic wave solver into a Navier-Stokes or viscous Stokes flow solver is an exercise related to this lecture 8. See the <a href="#exercises_-_lecture_8">exercise section</a> for detailed description.</p>
<p>Let&#39;s finally <strong>wrap-up</strong> recalling what we learned today about distributed computing in Julia using GPUs:</p>
<ul>
<li><p>We used fake parallelisation to understand the correct boundary exchange procedure.</p>

<li><p>We implemented 1D and 2D diffusion solvers in Julia using MPI for distributed memory parallelisation on both CPUs and GPUs &#40;using blocking messages&#41;.</p>

<li><p>We saw how combining <code>ParallelStencil.jl</code> with <code>ImplicitGlobalGrid.jl</code> permits to implement distributed memory parallelisation on multiple CPU and GPUs.</p>

</ul>

<p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p>
<h1 id=automatic_documentation_in_julia ><a href="#automatic_documentation_in_julia" class=header-anchor >Automatic documentation in Julia</a></h1>
<p>This lecture we will learn</p>
<ul>
<li><p>...</p>

</ul>

<p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p>
<h1 id=exercises_-_lecture_8 ><a href="#exercises_-_lecture_8" class=header-anchor >Exercises - lecture 8</a></h1>
<div class=warning ><div class=title >⚠️ Warning&#33;</div>
<div class=messg >Exercises have to be handed in as monolithic Julia scripts &#40;one code per script&#41; and uploaded to your private &#40;shared&#41; GitHub repository, in a <strong>specific folder for each lecture</strong>. The git commit hash &#40;or SHA&#41; of the final push needs to be uploaded on Moodle &#40;<a href="/course-101-0250-00/homework">more</a>&#41;.</div></div>
<div class=page-foot >
  <div class=copyright >
    <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/"><b>Edit this page on <img class=github-logo  src="https://unpkg.com/ionicons@5.1.2/dist/svg/logo-github.svg"></b></a><br>
    Last modified: November 08, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>