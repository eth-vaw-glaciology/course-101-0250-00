<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <script src="/libs/lunr/lunr.min.js"></script> <script src="/libs/lunr/lunr_index.js"></script> <script src="/libs/lunr/lunrclient.min.js"></script> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=stylesheet  href="/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/assets/favicon.png"> <title>Software install</title> <style> .content {max-width: 50rem} </style> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <img src="/assets/vaw_logo.png" style="width: 180px; height: auto; display: inline"> <div style="font-weight: margin-bottom: 0.5em"><a href="/"> Fall 2023</a> <span style="opacity: 0.7;">| <a href="http://www.vvz.ethz.ch/Vorlesungsverzeichnis/lerneinheit.view?semkez=2022W&ansicht=KATALOGDATEN&lerneinheitId=162403&lang=en"> ETHZ 101-0250-00</a></span></div> <br> <h1><a href="/">Solving partial differential equations in parallel on GPUs</a></h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by &nbsp; <a href="https://vaw.ethz.ch/en/people/person-detail.MjcwOTYw.TGlzdC8xOTYxLDE1MTczNjI1ODA=.html">Ludovic R√§ss</a>, &nbsp; <a href="https://vaw.ethz.ch/en/personen/person-detail.html?persid=124402">Mauro Werder</a>, &nbsp; <a href="https://www.cscs.ch/about/staff/">Samuel Omlin</a> & <br> <a href="https://vaw.ethz.ch/en/people/person-detail.MzAwMjIy.TGlzdC8xOTYxLDE1MTczNjI1ODA=.html">Ivan Utkin</a> </div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9; margin-bottom: 1.2cm;"> <a class="sidebar-nav-item " href="/"><b>Welcome</b></a> <a class="sidebar-nav-item " href="/logistics/">Logistics</a> <a class="sidebar-nav-item " href="/homework/">Homework</a> <a class="sidebar-nav-item active" href="/software_install/">Software install</a> <a class="sidebar-nav-item " href="/extras/">Extras</a> <br> <div class=course-section >Part 1 - Introduction</div> <a class="sidebar-nav-item " href="/lecture1/">Lecture 1 - Why Julia GPU</a> <a class="sidebar-nav-item " href="/lecture2/">Lecture 2 - PDEs & physical processes</a> <a class="sidebar-nav-item " href="/lecture3/">Lecture 3 - Solving elliptic PDEs</a> <div class=course-section >Part 2 - Solving PDEs on GPUs</div> <a class="sidebar-nav-item " href="/lecture4/">Lecture 4 - Porous convection</a> <a class="sidebar-nav-item " href="/lecture5/">Lecture 5 - Parallel computing</a> <a class="sidebar-nav-item " href="/lecture6/">Lecture 6 - GPU computing</a> <div class=course-section >Part 3 - Multi-GPU computing (projects)</div> <a class="sidebar-nav-item " href="/lecture7/">Lecture 7 - xPU computing</a> <a class="sidebar-nav-item " href="/lecture8/">Lecture 8 - Julia MPI & multi-xPU</a> <a class="sidebar-nav-item " href="/lecture9/">Lecture 9 - Multi-xPU & Projects</a> <a class="sidebar-nav-item " href="/lecture10/">Lecture 10 - Advanced optimisations</a> <div class=course-section >Final Projects</div> <a class="sidebar-nav-item " href="/final_proj/">Infos about final projects</a> </nav> <form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder="Enter search term" type=text > <input type=submit  value=Search  formaction="/search/index.html"> </form> <br> <br> </div> </div> <div class="content container"> <div class=franklin-content > <h1 id=software_install ><a href="#software_install" class=header-anchor >Software install</a></h1> <div class=franklin-toc ><ol><li><a href="#software_install">Software install</a><ol><li><a href="#opening_and_running_the_jupyter_julia_notebook">Opening and running the Jupyter Julia notebook</a><li><a href="#jupyterhub">JupyterHub</a><li><a href="#installing_julia_v18_or_later">Installing Julia v1.8 &#40;or later&#41;</a><li><a href="#running_julia">Running Julia</a><li><a href="#gpu_computing_on_piz_daint">GPU computing on Piz Daint</a></ol></ol></div> <h2 id=opening_and_running_the_jupyter_julia_notebook ><a href="#opening_and_running_the_jupyter_julia_notebook" class=header-anchor >Opening and running the Jupyter Julia notebook</a></h2> <h3 id=course_slides_and_lecture_material ><a href="#course_slides_and_lecture_material" class=header-anchor >Course slides and lecture material</a></h3> <p>All the course slides are <a href="https://jupyter.org/">Jupyter notebooks</a>; browser-based computational notebooks.</p> <p>Code cells are executed by putting the cursor into the cell and hitting <code>shift &#43; enter</code>. For more info see the <a href="https://jupyter-notebook.readthedocs.io/en/stable/">documentation</a>.</p> <h3 id=exercises_and_homework ><a href="#exercises_and_homework" class=header-anchor >Exercises and homework</a></h3> <p>The first two lecture&#39;s homework assignments will be <a href="https://jupyter.org/">Jupyter notebooks</a>. You&#39;ll find them on Moodle within your <a href="https://moodle-app2.let.ethz.ch/course/view.php?id&#61;20175">JupyterHub</a> space. You can execute them on the <a href="https://moodle-app2.let.ethz.ch/course/view.php?id&#61;20175">JupyterHub</a> or download them and run them them locally if you&#39;re already set-up.</p> <p>For submission, download the final <code>.ipynb</code> notebooks from the server, or collect the local <code>.ipynb</code> notebooks into a single local folder you then upload to Moodle. See <a href="/logistics">Logistics</a> and <a href="/homework">Homework</a> for details.</p> <p>Starting from lecture 3, exercise scripts will be mostly standalone regular Julia scripts that have to be uploaded to your private GitHub repo &#40;shared with the teaching staff only&#41;. Details in <a href="/logistics/#submission">Logistics</a>.</p> <h2 id=jupyterhub ><a href="#jupyterhub" class=header-anchor >JupyterHub</a></h2> <p>You can access the JupyterHub from the <strong>General</strong> section in <a href="https://moodle-app2.let.ethz.ch/course/view.php?id&#61;20175">Moodle</a>, clicking on <a href="https://moodle-app2.let.ethz.ch/course/view.php?id&#61;20175"><img src="/assets/JHub.png#badge" alt=JupyterHub  /></a></p> <p>Upon login to the server, you should see the following launcher environment, including a notebook &#40;file&#41; browser, ability to create a notebook, launch a Julia console &#40;REPL&#41;, or a regular terminal.</p> <p><img src="/assets/JHubLauncher.png" alt=JupyterHub  /></p> <div class=warning ><div class=title >‚ö†Ô∏è Warning&#33;</div> <div class=messg >It is recommended to duplicate and rename any files you are planning to work on and to download your work as back-up before leaving the session.</div></div> <h2 id=installing_julia_v18_or_later ><a href="#installing_julia_v18_or_later" class=header-anchor >Installing Julia v1.8 &#40;or later&#41;</a></h2> <p>Check you have an active internet connexion and <a href="https://julialang.org/downloads/">download Julia v1.8</a> for your platform following the install directions provided under <strong>&#91;help&#93;</strong>.</p> <p>Alternatively, open a terminal and download the binaries &#40;select the one for your platform&#41;:</p> <pre><code class="sh hljs">wget https://julialang-s3.julialang.org/bin/winnt/x64/1.8/julia-1.9.3-win64.exe <span class=hljs-comment ># Windows</span>
wget https://julialang-s3.julialang.org/bin/mac/x64/1.8/julia-1.9.3-mac64.dmg <span class=hljs-comment ># macOS</span>
wget https://julialang-s3.julialang.org/bin/linux/x64/1.8/julia-1.9.3-linux-x86_64.tar.gz <span class=hljs-comment ># Linux x86</span></code></pre> <p>Then extract them and add Julia to <code>PATH</code> &#40;usually done in your <code>.bashrc</code>, <code>.profile</code>, or <code>config</code> file&#41;.</p> <div class=note ><div class=title >üí° Note</div> <div class=messg ><em><strong>For Windows users:</strong></em> When installing Julia 1.8 on Windows, make sure to check the &quot;Add PATH&quot; tick or ensure Julia is on PATH &#40;see <strong>&#91;help&#93;</strong>&#41;. Julia&#39;s REPL has a built-in shell mode you can access typing <code>;</code> that natively works on Unix-based systems. On Windows, you can access the Windows shell by typing <code>Powershell</code> within the shell mode, and exit it typing <code>exit</code>, as described <a href="https://docs.julialang.org/en/v1/stdlib/REPL/#man-shell-mode">here</a>.</div></div> <h3 id=terminal_external_editor ><a href="#terminal_external_editor" class=header-anchor >Terminal &#43; external editor</a></h3> <p>Ensure you have a text editor with syntax highlighting support for Julia. <a href="https://www.sublimetext.com/download">Sublime Text</a> and <a href="https://atom.io">Atom</a> can be recommended.</p> <p>From within the terminal, type</p> <pre><code class="sh hljs">julia</code></pre>
<p>to make sure that the Julia REPL &#40;aka terminal&#41; starts. Then you should ba able to add <code>1&#43;1</code> and verify you get the expected result. Exit with <code>Ctrl-d</code>.</p>
<p><img src="/assets/julia_terminal.png" alt="Julia from Terminal" /></p>
<h3 id=vs_code ><a href="#vs_code" class=header-anchor >VS Code</a></h3>
<p>If you&#39;d enjoy a more IDE type of environment, <a href="https://code.visualstudio.com">check out VS Code</a>. Follow the <a href="https://github.com/julia-vscode/julia-vscode#getting-started">installation directions</a> for the <a href="https://www.julia-vscode.org">Julia VS Code extension</a>.</p>
<h4 id=vs_code_remote_-_ssh_setup ><a href="#vs_code_remote_-_ssh_setup" class=header-anchor >VS Code Remote - SSH setup</a></h4>
<p>VS Code&#39;s <a href="https://marketplace.visualstudio.com/items?itemName&#61;ms-vscode-remote.remote-ssh">Remote-SSH</a> extension allows you to connect and open a remote folder on any remote machine with a running SSH server. Once connected to a server, you can interact with files and folders anywhere on the remote filesystem &#40;<a href="https://code.visualstudio.com/docs/remote/ssh">more</a>&#41;.</p>
<ol>
<li><p>To get started, follow <a href="https://code.visualstudio.com/docs/remote/ssh#_installation">the install steps</a>.</p>

<li><p>Then, you can <a href="https://code.visualstudio.com/docs/remote/ssh#_connect-to-a-remote-host">connect to a remote host</a>, using <code>ssh user@hostname</code> and your password &#40;selecting <code>Remote-SSH: Connect to Host...</code> from the Command Palette&#41;.</p>

<li><p><a href="https://code.visualstudio.com/docs/remote/ssh#_remember-hosts-and-advanced-settings">Advanced options</a> permit you to <a href="#running_julia_interactively_on_piz_daint">access a remote compute node from within VS Code</a>.</p>

</ol>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >This remote configuration supports Julia graphics to render within VS Code&#39;s plot pane. However, this &quot;remote&quot; visualisation option is only functional when plotting from a Julia instance launched as <code>Julia: Start REPL</code> from the Command Palette. Displaying a plot from a Julia instance launched from the remote terminal &#40;which allows, e.g., to include custom options such as <code>ENV</code> variables or load modules&#41; will fail. To work around this limitation, select <code>Julia: Connect external REPL</code> from the Command Palette and follow the prompted instructions.</div></div>
<div class=warning ><div class=title >‚ö†Ô∏è Warning&#33;</div>
<div class=messg >The Remote-SSH setup is limited on Piz Daint because of a security issue, not allowing direct node execution nor supporting remote command execution which would be needed to correctly launch the Julia extension to allow for e.g. graphics redirection &#40;more <a href="https://user.cscs.ch/news/#23-10-2020-remote-vscode-configuration">here</a>&#41;.</div></div>
<h2 id=running_julia ><a href="#running_julia" class=header-anchor >Running Julia</a></h2>
<h3 id=first_steps ><a href="#first_steps" class=header-anchor >First steps</a></h3>
<p>Now that you have a running Julia install, launch Julia &#40;e.g. by typing <code>julia</code> in the shell since it should be on path&#41;</p>
<pre><code class="sh hljs">julia</code></pre>
<p>Welcome in the <a href="https://docs.julialang.org/en/v1/stdlib/REPL/">Julia REPL</a> &#40;command window&#41;. There, you have 3 &quot;modes&quot;, the standard</p>
<pre><code class="julia-repl hljs">[user@comp ~]$ julia
               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type &quot;?&quot; for help, &quot;]?&quot; for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.9.3 (2023-08-24)
 _/ |\__&#x27;_|_|_|\__&#x27;_|  |  Official https://julialang.org/ release
|__/                   |

<span class="hljs-meta prompt_">julia&gt;</span></code></pre>
<p>the shell mode by hitting <code>;</code>, where you can enter Unix commands,</p>
<pre><code class="julia-repl hljs"><span class=hljs-metas>shell&gt;</span></code></pre>
<p>and the <a href="https://docs.julialang.org/en/v1/stdlib/REPL/#Pkg-mode">Pkg mode</a> &#40;package manager&#41; by hitting <code>&#93;</code>, that will be used to add and manage packages, and environments,</p>
<pre><code class="julia-repl hljs"><span class=hljs-metap>(@v1.9) pkg&gt;</span></code></pre>
<p>You can interactively execute commands in the REPL, like adding two numbers</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-number >2</span>+<span class=hljs-number >2</span>
</span>4

<span class="hljs-meta prompt_">julia&gt;</span></code></pre>
<p>Within this class, we will mainly work with Julia scripts. You can run them using the <code>include&#40;&#41;</code> function in the REPL</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > include(<span class=hljs-string >&quot;my_script.jl&quot;</span>)</span></code></pre>
<p>Alternatively, you can also execute a Julia script from the shell</p>
<pre><code class="sh hljs">julia -O3 --check-bounds=no my_script.jl</code></pre>
<p>here passing the <code>-O3</code> optimisation flag, and the Julia <code>--check-bounds</code> flag set to <code>no</code> in order to deactivate out-of-bound checking.</p>
<h3 id=package_manager ><a href="#package_manager" class=header-anchor >Package manager</a></h3>
<p>The <a href="https://docs.julialang.org/en/v1/stdlib/REPL/#Pkg-mode">Pkg mode</a> permits you to install and manage Julia packages, and control the project&#39;s environment.</p>
<p>Environments or Projects are an efficient way that enable portability and reproducibility. Upon activating a local environment, you generate a local <code>Project.toml</code> file that stores the packages and version you are using within a specific project &#40;code-s&#41;, and a <code>Manifest.toml</code> file that keeps track locally of the state of the environment.</p>
<p>To activate an project-specific environment, navigate to your targeted project folder, launch Julia</p>
<pre><code class="sh hljs"><span class=hljs-built_in >mkdir</span> my_cool_project
<span class=hljs-built_in >cd</span> my_cool_project
julia</code></pre>
<p>and activate it</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > ]
</span>
<span class=hljs-metap>(@v1.9) pkg&gt;</span>

<span class=hljs-metap>(@v1.9) pkg&gt;</span> activate .
  Activating new environment at `~/my_cool_project/Project.toml`

<span class=hljs-metap>(my_cool_project) pkg&gt;</span></code></pre>
<p>Then, let&#39;s install the <code>Plots.jl</code> package</p>
<pre><code class="julia-repl hljs"><span class=hljs-metap>(my_cool_project) pkg&gt;</span> add Plots</code></pre>
<p>and check the status</p>
<pre><code class="julia-repl hljs"><span class=hljs-metap>(my_cool_project) pkg&gt;</span> st
      Status `~/my_cool_project/Project.toml`
  [91a5bcdd] Plots v1.22.3</code></pre>
<p>as well as the <code>.toml</code> files</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > ;
</span>
<span class=hljs-metas>shell&gt;</span> ls
Manifest.toml Project.toml</code></pre>
<p>We can now load <code>Plots.jl</code> and plot some random noise</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >using</span> Plots
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > heatmap(rand(<span class=hljs-number >10</span>,<span class=hljs-number >10</span>))</span></code></pre>
<p>Let&#39;s assume you&#39;re handed your <code>my_cool_project</code> to someone to reproduce your cool random plot. To do so, you can open julia from the <code>my_cool_project</code> folder with the <code>--project</code> option</p>
<pre><code class="sh hljs"><span class=hljs-built_in >cd</span> my_cool_project
julia --project</code></pre>
<p>Or you can rather activate it afterwards</p>
<pre><code class="sh hljs"><span class=hljs-built_in >cd</span> my_cool_project
julia</code></pre>
<p>and then,</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > ]
</span>
<span class=hljs-metap>(@v1.9) pkg&gt;</span> activate .
  Activating environment at `~/my_cool_project/Project.toml`

<span class=hljs-metap>(my_cool_project) pkg&gt;</span>

<span class=hljs-metap>(my_cool_project) pkg&gt;</span> st
      Status `~/my_cool_project/Project.toml`
  [91a5bcdd] Plots v1.22.3</code></pre>
<p>Here we go, you can now share that folder with colleagues or with yourself on another machine and have a reproducible environment üôÇ</p>
<h3 id=multi-threading_on_cpus ><a href="#multi-threading_on_cpus" class=header-anchor >Multi-threading on CPUs</a></h3>
<p>On the CPU, <a href="https://docs.julialang.org/en/v1/manual/multi-threading/#man-multithreading">multi-threading</a> is made accessible via <a href="https://docs.julialang.org/en/v1/base/multi-threading/">Base.Threads</a>. To make use of threads, Julia needs to be launched with</p>
<pre><code class="sh hljs">julia --project -t auto</code></pre>
<p>which will launch Julia with as many threads are there are cores on your machine &#40;including hyper-threaded cores&#41;. Alternatively set the environment variable <code>JULIA_NUM_THREADS</code>, e.g. <code>export JULIA_NUM_THREADS&#61;2</code> to enable 2 threads.</p>
<h3 id=julia_on_gpus ><a href="#julia_on_gpus" class=header-anchor >Julia on GPUs</a></h3>
<p>The <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> module permits to launch compute kernels on Nvidia GPUs natively from within Julia. <a href="https://juliagpu.org">JuliaGPU</a> provides further reading and <a href="https://juliagpu.gitlab.io/CUDA.jl/tutorials/introduction/">introductory material</a> about GPU ecosystems within Julia.</p>
<h3 id=julia_mpi ><a href="#julia_mpi" class=header-anchor >Julia MPI</a></h3>
<p>The following steps permit you to install <a href="https://github.com/JuliaParallel/MPI.jl">MPI.jl</a> on your machine and test it:</p>
<ol>
<li><p>If Julia MPI is a dependency of a Julia project MPI.jl should have been added upon executing the <code>instantiate</code> command from within the package manager <a href="#package_manager">see here</a>. If not, MPI.jl can be added from within the package manager &#40;typing <code>add MPI</code> in package mode&#41;.</p>

<li><p>Install <code>mpiexecjl</code>:</p>

</ol>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >using</span> MPI
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > MPI.install_mpiexecjl()
</span>[ Info: Installing `mpiexecjl` to `HOME/.julia/bin`...
[ Info: Done!</code></pre>
<ol start=3 >
<li><p>Then, one should add <code>HOME/.julia/bin</code> to PATH in order to launch the Julia MPI wrapper <code>mpiexecjl</code>.</p>

<li><p>Running a Julia MPI code <code>&lt;my_script.jl&gt;</code> on <code>np</code> MPI processes:</p>

</ol>
<pre><code class="sh hljs">$ mpiexecjl -n np julia --project &lt;my_script.jl&gt;</code></pre>
<ol start=5 >
<li><p>To test the Julia MPI installation, launch the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/"><code>l8_hello_mpi.jl</code></a> using the Julia MPI wrapper <code>mpiexecjl</code> &#40;located in <code>~/.julia/bin</code>&#41; on, e.g., 4 processes:</p>

</ol>
<pre><code class="sh hljs">$ mpiexecjl -n 4 julia --project ./l8_hello_mpi.jl
$ Hello world, I am 0 of 3
$ Hello world, I am 1 of 3
$ Hello world, I am 2 of 3
$ Hello world, I am 3 of 3</code></pre>
<div class=note ><div class=title >üí° Note</div>
<div class=messg ><p>On macOS, you may encounter <a href="https://github.com/JuliaParallel/MPI.jl/issues/407">this issue</a>. To fix it, define following <code>ENV</code> variable:</p>
<pre><code class="sh hljs">$ <span class=hljs-built_in >export</span> MPICH_INTERFACE_HOSTNAME=localhost</code></pre>
<p>and add <code>-host localhost</code> to the execution script:</p>
<pre><code class="sh hljs">$ mpiexecjl -n 4 -host localhost julia --project ./hello_mpi.jl</code></pre></div></div>
<p><em>For running Julia at scale on Piz Daint, refer to the &#91;Julia MPI GPU on Piz Daint&#93;&#40;#julia</em>mpi<em>gpu</em>on<em>piz</em>daint&#41; section._</p>
<h2 id=gpu_computing_on_piz_daint ><a href="#gpu_computing_on_piz_daint" class=header-anchor >GPU computing on Piz Daint</a></h2>
<p>GPU computing on <a href="https://www.cscs.ch/computers/piz-daint/">Piz Daint</a> at <a href="https://www.cscs.ch">CSCS</a>. The supercomputer Piz Daint is composed of about 5700 compute nodes, each hosting a single Nvidia P100 16GB PCIe graphics card. We have a 2000 node hour allocation for our course on the system.</p>
<div class=warning ><div class=title >‚ö†Ô∏è Warning&#33;</div>
<div class=messg >Since the course allocation is exceptional, make sure not to open any help tickets directly at CSCS help, but report questions and issue to our <strong>helpdesk</strong> room on Element. Also, better ask about good practice before launching anything you are unsure in order to avoid any disturbance on the machine.</div></div>
<p>The login procedure is as follow. First a login to the front-end &#40;or login&#41; machine Ela &#40;hereafter referred to as &quot;ela&quot;&#41; is needed before one can log into Piz Daint. Login is performed using <code>ssh</code>. We will set-up a proxy-jump in order to simplify the procedure and directly access Piz Daint &#40;hereafter referred to as &quot;daint&quot;&#41;</p>
<p>Both daint and ela share a <code>home</code> folder. However, the <code>scratch</code> folder is only accessible on daint. We can use VS code in combination with the proxy-jump to conveniently edit files on daint&#39;s scratch directly. We will use Julia module to have all Julia-related tools ready.</p>
<p>Please follow the steps listed hereafter to get ready and set-up on daint.</p>
<h3 id=account_setup ><a href="#account_setup" class=header-anchor >Account setup</a></h3>
<ol>
<li><p>Fetch your personal username and password credentials from the shared Polybox folder, stored in a <code>daint_login.md</code> file.</p>

<li><p>Open a terminal &#40;in Windows, use a tool as e.g. <a href="">PuTTY</a> or <a href="https://learn.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse?tabs&#61;gui">OpenSSH</a>&#41; and <code>ssh</code> to ela and enter the password:</p>

</ol>
<pre><code class="sh hljs">ssh &lt;username&gt;@ela.cscs.ch</code></pre>
<ol start=3 >
<li><p>On ela, change the password to another one and remember it&#33; Password policy. The new password should comply with the following:</p>
<ul>
<li><p>be at least 12 characters</p>

<li><p>include upper and lower case letters</p>

<li><p>include numeric digits</p>

<li><p>include special characters like <code># , . / : &#61; ? @ &#91; &#93; ^ &#123; &#125; ~</code></p>

</ul>

</ol>
<pre><code class="sh hljs">[<span class=hljs-built_in >test</span>@ela1 ~]$ kpasswd
Password <span class=hljs-keyword >for</span> &lt;username&gt;@CSCS.CH: (current password)
Enter new password: (new password)
Enter it again: (new password)</code></pre>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >üëâ For Lecture 6, you can jump directly to the <a href="#jupyterlab_access_on_piz_daint">JupyterLab</a> setup.</div></div>
<ol start=4 >
<li><p>Generate a <code>ed25519</code> keypair as described in the <a href="https://user.cscs.ch/access/auth/#generating-ssh-keys-if-not-required-to-provide-a-2nd-factor">CSCS user website</a>. On your local machine &#40;not ela&#41;, do <code>ssh-keygen</code> leaving the passphrase empty. Then copy your public key to the remote server &#40;ela&#41; using <code>ssh-copy-id</code>. Alternatively, you can copy the keys manually as described in the <a href="https://user.cscs.ch/access/auth/#generating-ssh-keys-if-not-required-to-provide-a-2nd-factor">CSCS user website</a>.</p>

</ol>
<pre><code class="sh hljs">ssh-keygen -t ed25519
ssh-copy-id &lt;username&gt;@ela.cscs.ch
ssh-copy-id -i ~/.ssh/id_ed25519.pub &lt;username&gt;@ela.cscs.ch</code></pre>
<ol start=5 >
<li><p>Edit your ssh config file located in <code>~/.ssh/config</code> and add following entries to it, making sure to replace <code>&lt;username&gt;</code> and key file with correct names, if needed:</p>

</ol>
<pre><code class="sh hljs">Host ela
  HostName ela.cscs.ch
  User &lt;username&gt;
  IdentityFile ~/.ssh/id_ed25519

Host daint
  HostName daint.cscs.ch
  User &lt;username&gt;
  IdentityFile ~/.ssh/id_ed25519
  ProxyJump ela
  RequestTTY <span class=hljs-built_in >yes</span>
  RemoteCommand module load daint-gpu Julia/1.7.2-CrayGNU-21.09-cuda &amp;&amp; bash -l

Host nid*
  HostName %h
  User &lt;username&gt;
  IdentityFile ~/.ssh/id_ed25519
  ProxyJump daint
  RequestTTY <span class=hljs-built_in >yes</span>
  RemoteCommand module load daint-gpu Julia/1.7.2-CrayGNU-21.09-cuda &amp;&amp; bash -l</code></pre>
<ol start=6 >
<li><p>Now you should be able to perform password-less login to daint as following</p>

</ol>
<pre><code class="sh hljs">ssh daint</code></pre>
<p>Moreover, you will get the Julia related modules loaded as we add the <code>RemoteCommand</code></p>
<blockquote>
<p>At this stage, you are logged into daint, but still on a login node and not a compute node.</p>
</blockquote>
<p>You can reach your home folder upon typing <code>&#36;HOME</code>, and your scratch space upon typing <code>&#36;SCRATCH</code>. Always make sure to run and save files from scratch folder.</p>
<div class=note ><div class=title >üí° Note</div>
<div class=messg ><p>To make things easier, you can create a soft link from your <code>&#36;HOME</code> pointing to <code>&#36;SCRATCH</code> as this will also be useful in a JupyterLab setting</p>
<pre><code class="sh hljs"><span class=hljs-built_in >ln</span> -s <span class=hljs-variable >$SCRATCH</span> scratch</code></pre></div></div>
<div class=warning ><div class=title >‚ö†Ô∏è Warning&#33;</div>
<div class=messg ><p>There is interactive visualisation on daint. Make sure to produce <code>png</code> or <code>gifs</code>. Also to avoid plotting to fail, make sure to set the following <code>ENV&#91;&quot;GKSwstype&quot;&#93;&#61;&quot;nul&quot;</code> in the code. Also, it may be good practice to define the animation directory to avoid filling a <code>tmp</code>, such as</p>
<pre><code class="julia hljs"><span class=hljs-literal >ENV</span>[<span class=hljs-string >&quot;GKSwstype&quot;</span>]=<span class=hljs-string >&quot;nul&quot;</span>
<span class=hljs-keyword >if</span> isdir(<span class=hljs-string >&quot;viz_out&quot;</span>)==<span class=hljs-literal >false</span> mkdir(<span class=hljs-string >&quot;viz_out&quot;</span>) <span class=hljs-keyword >end</span>
loadpath = <span class=hljs-string >&quot;./viz_out/&quot;</span>; anim = Animation(loadpath,<span class=hljs-built_in >String</span>[])
println(<span class=hljs-string >&quot;Animation directory: <span class=hljs-subst >$(anim.dir)</span>&quot;</span>)</code></pre></div></div>
<h3 id=running_julia_interactively_on_piz_daint ><a href="#running_julia_interactively_on_piz_daint" class=header-anchor >Running Julia interactively on Piz Daint</a></h3>
<p>So now, how do we actually run some GPU Julia code on Piz Daint?</p>
<ol>
<li><p>Open a terminal &#40;other than from within VS code&#41; and login to daint:</p>

</ol>
<pre><code class="sh hljs">ssh daint</code></pre>
<ol start=2 >
<li><p>The next step is to secure an allocation using <code>salloc</code>, a functionality provided by the SLURM scheduler. Use <code>salloc</code> command to allocate one node &#40;<code>N1</code>&#41; and one process &#40;<code>n1</code>&#41; on the GPU partition <code>-C&#39;gpu&#39;</code> on the project <code>class04</code> for 1 hour:</p>

</ol>
<pre><code class="sh hljs">salloc -C<span class=hljs-string >&#x27;gpu&#x27;</span> -Aclass04 -N1 -n1 --time=01:00:00</code></pre>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >You can check the status of the allocation typing <code>squeue -u &lt;username&gt;</code>.</div></div>
<p>üëâ <em>Running <strong>remote job</strong> instead? <a href="#running_a_remote_job_on_piz_daint">Jump right there</a></em></p>
<ol start=3 >
<li><p>Make sure to remember the <strong>node number</strong> returned upon successful allocation, e.g., <code>salloc: Nodes nid02145 are ready for job</code></p>

<li><p>Once you have your allocation and the node &#40;here <code>nid02145</code>&#41; you requested, open another terminal &#40;tab&#41; <strong>without closing the previous one</strong> and <code>ssh</code> to your node replacing the <code>XXXXX</code> with appropriate node id from step 2. If needed, accept the key fingerprint prompt and you should be on the node with Julia environment loaded.</p>

</ol>
<pre><code class="sh hljs">ssh nidXXXXX</code></pre>
<ol start=4 >
<li><p>You should not be able to launch Julia</p>

</ol>
<pre><code class="sh hljs">julia</code></pre>
<h4 id=only_the_first_time ><a href="#only_the_first_time" class=header-anchor >üëÄ ONLY the first time</a></h4>
<ol>
<li><p>Assuming you are on a node and launched Julia. To finalise your install, enter the package manager and query status <code>&#93; st</code> and add <code>CUDA</code>:</p>

</ol>
<pre><code class="julia-repl hljs"><span class=hljs-metap>(@1.7-daint-gpu) pkg&gt;</span> st
  Installing known registries into `/scratch/snx3000/class230/../julia/class230/daint-gpu`
      Status `/scratch/snx3000/julia/class230/daint-gpu/environments/1.7-daint-gpu/Project.toml` (empty project)

<span class=hljs-metap>(@1.7-daint-gpu) pkg&gt;</span> add CUDA</code></pre>
<ol start=2 >
<li><p>Then load it and query version info</p>

</ol>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >using</span> CUDA
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > CUDA.versioninfo()
</span>  Downloaded artifact: CUDA_compat
CUDA toolkit 11.0, local installation
NVIDIA driver 470.57.2, for CUDA 11.4
CUDA driver 11.7</code></pre>
<ol start=3 >
<li><p>Try out your first calculation on the P100 GPU</p>

</ol>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > a = CUDA.ones(<span class=hljs-number >3</span>,<span class=hljs-number >4</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > b = CUDA.rand(<span class=hljs-number >3</span>,<span class=hljs-number >4</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > c = CUDA.zeros(<span class=hljs-number >3</span>,<span class=hljs-number >4</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > c. = a .+ b</span></code></pre>
<p>If you made it up to here, you&#39;re all set üöÄ</p>
<div class=note ><div class=title >üí° Note</div>
<div class=messg ><p>Alternatively, you can also access a compute node after having performed the <code>salloc</code> step by following:</p>
<pre><code class="sh hljs">srun -n1 --pty /bin/bash -l
module load daint-gpu Julia/1.7.2-CrayGNU-21.09-cuda</code></pre></div></div>
<h4 id=monitoring_gpu_usage ><a href="#monitoring_gpu_usage" class=header-anchor >Monitoring GPU usage</a></h4>
<p>You can use the <code>nvidia-smi</code> command to monitor GPU usage on a compute node on daint. Just type in the terminal or with Julia&#39;s REPL &#40;in shell mode&#41;:</p>
<pre><code class="julia-repl hljs"><span class=hljs-metas>shell&gt;</span> nvidia-smi
Tue Oct 25 08:18:11 2022
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 470.57.02    Driver Version: 470.57.02    CUDA Version: 11.4     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|                               |                      |               MIG M. |
|===============================+======================+======================|
|   0  Tesla P100-PCIE...  On   | 00000000:02:00.0 Off |                    0 |
| N/A   23C    P0    25W / 250W |      0MiB / 16280MiB |      0%   E. Process |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+

+-----------------------------------------------------------------------------+
| Processes:                                                                  |
|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |
|        ID   ID                                                   Usage      |
|=============================================================================|
|  No running processes found                                                 |
+-----------------------------------------------------------------------------+</code></pre>
<h3 id=running_a_remote_job_on_piz_daint ><a href="#running_a_remote_job_on_piz_daint" class=header-anchor >Running a remote job on Piz Daint</a></h3>
<p>If you do not want to use an interactive session you can use the <code>sbatch</code> command to launch a job remotely on the machine. Example of a <code>submit.sh</code> you can launch &#40;without need of an allocation&#41; as <code>sbatch submit.sh</code>:</p>
<pre><code class="sh hljs"><span class=hljs-meta >#!/bin/bash -l</span>
<span class=hljs-comment >#SBATCH --job-name=&quot;my_gpu_run&quot;</span>
<span class=hljs-comment >#SBATCH --output=my_gpu_run.%j.o</span>
<span class=hljs-comment >#SBATCH --error=my_gpu_run.%j.e</span>
<span class=hljs-comment >#SBATCH --time=00:30:00</span>
<span class=hljs-comment >#SBATCH --nodes=1</span>
<span class=hljs-comment >#SBATCH --ntasks-per-node=1</span>
<span class=hljs-comment >#SBATCH --partition=normal</span>
<span class=hljs-comment >#SBATCH --constraint=gpu</span>
<span class=hljs-comment >#SBATCH --account class04</span>

module load daint-gpu
module load Julia/1.7.2-CrayGNU-21.09-cuda

srun julia -O3 --check-bounds=no &lt;my_julia_gpu_script.jl&gt;</code></pre>
<h3 id=jupyterlab_access_on_piz_daint ><a href="#jupyterlab_access_on_piz_daint" class=header-anchor >JupyterLab access on Piz Daint</a></h3>
<p>Some tasks and homework, are prepared as Jupyter notebook and can easily be executed within a JupyterLab environment. CSCS offers a convenient <a href="https://user.cscs.ch/tools/interactive/jupyterlab/#access-and-setup">JupyterLab access</a>.</p>
<ol>
<li><p>If possible, create a soft link from your <code>&#36;HOME</code> pointing to <code>&#36;SCRATCH</code> &#40;do this on daint&#41;:</p>

</ol>
<pre><code class="sh hljs"><span class=hljs-built_in >ln</span> -s <span class=hljs-variable >$SCRATCH</span> scratch</code></pre>
<ol start=2 >
<li><p>Head to <a href="https://jupyter.cscs.ch/">https://jupyter.cscs.ch/</a>.</p>

<li><p>Login with your username and password you&#39;ve set for in the <a href="#account_setup">Account setup</a> step</p>

<li><p>Select <code>Node Type: GPU</code>, <code>Node: 1</code> and the duration you want and <strong>Launch JupyterLab</strong>.</p>

<li><p>From with JupyterLab, upload the notebook to work on and get started&#33;</p>

</ol>
<h3 id=transferring_files_on_piz_daint ><a href="#transferring_files_on_piz_daint" class=header-anchor >Transferring files on Piz Daint</a></h3>
<p>Given that daint&#39;s <code>scratch</code> is not mounted on ela, it is unfortunately impossible to transfer files from/to daint using common sftp tools as they do not support the proxy-jump. Various solutions exist to workaround this, including manually handling transfers over terminal, using a tool which supports proxy-jump, or VS code.</p>
<p>To use VS code as development tool, make sure to have installed the <code>Remote-SSH</code> extension as described in the <a href="#vs_code_remote_-_ssh_setup">VS Code Remote - SSH setup</a> section. Then, in VS code Remote-SSH settings, make sure the <code>Remote Server Listen On Socket</code> is set to <code>true</code>.</p>
<p>The next step should work out of the box. You should be able to select <code>daint</code> from within the Remote Explorer side-pane. You should get logged into daint. You now can browse your files, change directory to, e.g., your scratch at <code>/scratch/snx3000/&lt;username&gt;/</code>. Just drag and drop files in there to transfer them.</p>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >You can also use VS code&#39;s integrated terminal to launch Julia on daint. However, you can&#39;t use the Julia extension nor the direct node login and would have to use <code>srun -n1 --pty /bin/bash -l</code> and load the needed modules, namely <code>module load daint-gpu Julia/1.7.2-CrayGNU-21.09-cuda</code>.</div></div>
<h3 id=julia_mpi_gpu_on_piz_daint ><a href="#julia_mpi_gpu_on_piz_daint" class=header-anchor >Julia MPI GPU on Piz Daint</a></h3>
<p>The following step should allow you to run distributed memory parallelisation application on multiple GPU nodes on Piz Daint.</p>
<ol>
<li><p>Make sure to have the Julia GPU environment loaded</p>

</ol>
<pre><code class="sh hljs">module load daint-gpu
module load Julia/1.7.2-CrayGNU-21.09-cuda</code></pre>
<ol start=2 >
<li><p>Then, you would need to allocate more than one node, let&#39;s say 4 nodes for 2 hours, using <code>salloc</code></p>

</ol>
<pre><code class="julia hljs">salloc -C&#x27;gpu&#x27; -Aclass04 -N4 -n4 --time=<span class=hljs-number >02</span>:<span class=hljs-number >00</span>:<span class=hljs-number >00</span></code></pre>
<ol start=3 >
<li><p>To launch a Julia &#40;GPU&#41; MPI script on 4 nodes &#40;GPUs&#41; using MPI, you can simply use <code>srun</code></p>

</ol>
<pre><code class="sh hljs">srun -n4 julia -O3 --check-bounds=no &lt;my_script.jl&gt;</code></pre>
<h4 id=cuda-aware_mpi_on_piz_daint ><a href="#cuda-aware_mpi_on_piz_daint" class=header-anchor >CUDA-aware MPI on Piz Daint</a></h4>
<p>You may want to leverage CUDA-aware MPI, i.e., passing GPU pointers directly through the MPI-based update halo functions, then make sure to</p>
<ol>
<li><p>Export the appropriate <code>ENV</code> vars</p>

</ol>
<pre><code class="sh hljs"><span class=hljs-built_in >export</span> MPICH_RDMA_ENABLED_CUDA=1
<span class=hljs-built_in >export</span> IGG_CUDAAWARE_MPI=1</code></pre>
<ol start=2 >
<li><p>Because of a current issue with Cray-MPICH &#40;the Cray MPI distribution used on Piz Daint&#41;, you need also to dynamically preload <code>libcudart.so</code> library. This can be achieved upon launching your Julia executable script</p>

</ol>
<pre><code class="sh hljs">LD_PRELOAD=<span class=hljs-string >&quot;/usr/lib64/libcuda.so:/usr/local/cuda/lib64/libcudart.so&quot;</span> julia -O3 --check-bounds=no &lt;my_script.jl&gt;</code></pre>
<p>In the CUDA-aware MPI case, a more robust launch procedure may be to launch a shell script via <code>srun</code>. You can create, e.g., a <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l8_scripts/l8_runme_mpi_daint.sh"><code>runme_mpi_daint.sh</code></a> script containing:</p>
<pre><code class="sh hljs"><span class=hljs-meta >#!/bin/bash -l</span>

module load daint-gpu
module load Julia/1.7.2-CrayGNU-21.09-cuda

<span class=hljs-built_in >export</span> MPICH_RDMA_ENABLED_CUDA=1
<span class=hljs-built_in >export</span> IGG_CUDAAWARE_MPI=1

LD_PRELOAD=<span class=hljs-string >&quot;/usr/lib64/libcuda.so:/usr/local/cuda/lib64/libcudart.so&quot;</span> julia -O3 --check-bounds=no &lt;my_script.jl&gt;</code></pre>
<p>Which you then launch using <code>srun</code> upon having made it executable &#40;<code>chmod &#43;x runme_mpi_daint.sh</code>&#41;</p>
<pre><code class="sh hljs">srun -n4 ./runme_mpi_daint.sh</code></pre>
<p>If you do not want to use an interactive session you can use the <code>sbatch</code> command to launch a job remotely on the machine. Example of a <code>sbatch_mpi_daint.sh</code> you can launch &#40;without need of an allocation&#41; as <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l8_scripts/l8_sbatch_mpi_daint.sh"><code>sbatch sbatch_mpi_daint.sh</code></a>:</p>
<pre><code class="sh hljs"><span class=hljs-meta >#!/bin/bash -l</span>
<span class=hljs-comment >#SBATCH --job-name=&quot;diff2D&quot;</span>
<span class=hljs-comment >#SBATCH --output=diff2D.%j.o</span>
<span class=hljs-comment >#SBATCH --error=diff2D.%j.e</span>
<span class=hljs-comment >#SBATCH --time=00:05:00</span>
<span class=hljs-comment >#SBATCH --nodes=4</span>
<span class=hljs-comment >#SBATCH --ntasks-per-node=1</span>
<span class=hljs-comment >#SBATCH --partition=normal</span>
<span class=hljs-comment >#SBATCH --constraint=gpu</span>
<span class=hljs-comment >#SBATCH --account class04</span>

module load daint-gpu
module load Julia/1.7.2-CrayGNU-21.09-cuda

<span class=hljs-built_in >export</span> MPICH_RDMA_ENABLED_CUDA=1
<span class=hljs-built_in >export</span> IGG_CUDAAWARE_MPI=1

srun -n4 bash -c <span class=hljs-string >&#x27;LD_PRELOAD=&quot;/usr/lib64/libcuda.so:/usr/local/cuda/lib64/libcudart.so&quot; julia -O3 --check-bounds=no &lt;my_julia_mpi_gpu_script.jl&gt;&#x27;</span></code></pre>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >The 2 scripts above can be found in the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l8_scripts/">scripts</a> folder.</div></div>
<div class=page-foot >
  <div class=copyright >
    <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/"><b>Edit this page on <img class=github-logo  src="https://unpkg.com/ionicons@5.1.2/dist/svg/logo-github.svg"></b></a><br>
    Last modified: September 07, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>