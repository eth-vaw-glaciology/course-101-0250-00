<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <script src="/libs/lunr/lunr.min.js"></script> <script src="/libs/lunr/lunr_index.js"></script> <script src="/libs/lunr/lunrclient.min.js"></script> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=stylesheet  href="/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/assets/favicon.png"> <title>Lecture 3</title> <style> .content {max-width: 50rem} </style> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <img src="/assets/vaw_logo.png" style="width: 180px; height: auto; display: inline"> <div style="font-weight: margin-bottom: 0.5em"><a href="/"> Fall 2022</a> <span style="opacity: 0.7;">| <a href="http://www.vvz.ethz.ch/Vorlesungsverzeichnis/lerneinheit.view?semkez=2022W&ansicht=KATALOGDATEN&lerneinheitId=162403&lang=en"> ETHZ 101-0250-00</a></span></div> <br> <h1><a href="/">Solving partial differential equations in parallel on GPUs</a></h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by &nbsp; <a href="https://vaw.ethz.ch/en/people/person-detail.MjcwOTYw.TGlzdC8xOTYxLDE1MTczNjI1ODA=.html">Ludovic R√§ss</a>, &nbsp; <a href="https://vaw.ethz.ch/en/personen/person-detail.html?persid=124402">Mauro Werder</a>, &nbsp; <a href="https://www.cscs.ch/about/staff/">Samuel Omlin</a> & <br> <a href="https://vaw.ethz.ch/en/people/person-detail.MzAwMjIy.TGlzdC8xOTYxLDE1MTczNjI1ODA=.html">Ivan Utkin</a> </div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9; margin-bottom: 1.2cm;"> <a class="sidebar-nav-item " href="/"><b>Welcome</b></a> <a class="sidebar-nav-item " href="/logistics/">Logistics</a> <a class="sidebar-nav-item " href="/homework/">Homework</a> <a class="sidebar-nav-item " href="/software_install/">Software install</a> <a class="sidebar-nav-item " href="/extras/">Extras</a> <br> <div class=course-section >Part 1 - Introduction</div> <a class="sidebar-nav-item " href="/lecture1/">Lecture 1 - Why Julia GPU</a> <a class="sidebar-nav-item " href="/lecture2/">Lecture 2 - PDEs & physical processes</a> <a class="sidebar-nav-item active" href="/lecture3/">Lecture 3 - Solving elliptic PDEs</a> <div class=course-section >Part 2 - Solving PDEs on GPUs</div> <a class="sidebar-nav-item " href="/lecture4/">Lecture 4 - Porous convection</a> <a class="sidebar-nav-item " href="/lecture5/">Lecture 5 - Parallel computing</a> <a class="sidebar-nav-item " href="/lecture6/">Lecture 6 - GPU computing & perf</a> <div class=course-section >Part 3 - Multi-GPU computing (projects)</div> <a class="sidebar-nav-item " href="/lecture7/">Lecture 7 - XPU computing</a> <a class="sidebar-nav-item " href="/lecture8/">Lecture 8 - Julia MPI & multi-XPU</a> <a class="sidebar-nav-item " href="/lecture9/">Lecture 9 - Advanced optimisations</a> <div class=course-section >Final Projects</div> <a class="sidebar-nav-item " href="/lecture10/">Lecture 10 - Final projects</a> </nav> <form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder="Enter search term" type=text > <input type=submit  value=Search  formaction="/search/index.html"> </form> <br> <br> </div> </div> <div class="content container"> <div class=franklin-content > <h1 id=lecture_3 ><a href="#lecture_3" class=header-anchor >Lecture 3</a></h1> <blockquote> <p><strong>Agenda</strong><br />üìö Solving elliptic PDEs, 1D to 2D<br />üíª Personal Julia install, Julia&#39;s <code>Project</code> environment, Julia&#39;s package manager<br />üöß Exercises:</p> <ul> <li><p>Damped wave equation in 2D</p> <li><p>Port 1D codes to 2D</p> </ul> </blockquote> <p><hr /> </p> <p><a id=content  class=anchor ></a> <strong>Content</strong></p> <div class=franklin-toc ><ol><li><a href="#lecture_3">Lecture 3</a><li><a href="#solving_elliptic_pdes">Solving elliptic PDEs</a><ol><li><a href="#accelerating_elliptic_solver_convergence_intuition">Accelerating elliptic solver convergence: intuition</a><li><a href="#damped_wave_equation">Damped wave equation</a><li><a href="#problem_of_finding_the_iteration_parameters">Problem of finding the iteration parameters</a><li><a href="#pseudo-transient_method">Pseudo-transient method</a><li><a href="#dispersion_analysis_of_the_pdes">Dispersion analysis of the PDEs</a></ol><li><a href="#julias_repl_the_package_manager_pkgjl_and_essential_packages">Julia&#39;s REPL, the Package manager &#40;Pkg.jl&#41;, and essential packages</a><ol><li><a href="#julia_repl">Julia REPL</a><li><a href="#julia_package_manager">Julia Package manager</a><li><a href="#essential_packages_for_your_global_environment">Essential packages for your global environment</a></ol><li><a href="#exercises_-_lecture_3">Exercises - lecture 3</a><ol><li><a href="#exercise_1_-_acoustic_waves_in_2d">Exercise 1 - <strong>Acoustic waves in 2D</strong></a><li><a href="#exercise_2_-_acoustic_waves_in_2d_-_v2">Exercise 2 - <strong>Acoustic waves in 2D - v2</strong></a><li><a href="#exercise_3_-_acoustic_waves_in_2d_-_v3">Exercise 3 - <strong>Acoustic waves in 2D - v3</strong></a><li><a href="#exercise_4_-_seismic_p-waves">Exercise 4 - <strong>Seismic P-waves</strong></a></ol></ol></div> <p><a href="#exercises_-_lecture_3"><em>üëâ get started with exercises</em></a></p> <hr /> <h1 id=solving_elliptic_pdes ><a href="#solving_elliptic_pdes" class=header-anchor >Solving elliptic PDEs</a></h1> <h3 id=the_goal_of_this_lecture_3_is_to_familiarise_or_refresh_with ><a href="#the_goal_of_this_lecture_3_is_to_familiarise_or_refresh_with" class=header-anchor >The goal of this lecture 3 is to familiarise &#40;or refresh&#41; with:</a></h3> <ul> <li><p>The damped wave equation</p> <li><p>Spectral analysis of linear PDEs</p> <li><p>Pseudo-transient method for solving elliptic PDEs</p> <li><p>Spatial discretisation: 1D and 2D</p> </ul> <p>In the previous lecture, we established that the solution to the elliptic PDE could be obtained through integrating in time a corresponding parabolic PDE:</p> \[ \frac{\partial C}{\partial t} - \frac{\partial^2 C}{\partial x^2} = 0 \] <p>and discussed the limitation of this approach, for numerical modelling, i.e., the quadratic dependence of the number of time steps on the number of grid points in spatial discretisation.</p> <center> <video width="80%" autoplay loop controls src="../assets/literate_figures/diffusion_1D_steady_state.mp4"/> </center> <h2 id=accelerating_elliptic_solver_convergence_intuition ><a href="#accelerating_elliptic_solver_convergence_intuition" class=header-anchor >Accelerating elliptic solver convergence: intuition</a></h2> <p>In this lecture, we&#39;ll improve the convergence rate of the elliptic solver, and consider the generalisation to higher dimensions</p> <p>Let&#39;s recall the stability conditions for diffusion and acoustic wave propagation:</p> <pre><code class=language-julia >dt &#61; dx^2/dc/2      # diffusion
dt &#61; dx/sqrt&#40;1/Œ≤/œÅ&#41; # acoustic wave propagation</code></pre> <p>We can see that the acceptable time step for an acoustic problem is proportional to the grid spacing <code>dx</code>, and not <code>dx^2</code> as for the diffusion.</p> <p>The number of time steps required for the wave to propagate through the domain is only proportional to the number of grid points <code>nx</code>.</p> <p>Can we use that information to reduce the time required for the elliptic solver to converge? In the solution to the wave equation, the waves do not attenuate with time: <em>there is no steady state&#33;</em></p> <center> <video width="80%" autoplay loop controls src="../assets/literate_figures/acoustic_1D.mp4"/> </center> <h2 id=damped_wave_equation ><a href="#damped_wave_equation" class=header-anchor >Damped wave equation</a></h2> <p>Let&#39;s add diffusive properties to the wave equation by simply combining the physics:</p> \[\begin{aligned} \rho\frac{\partial V_x}{\partial t} &= -\frac{\partial P}{\partial x} \\[10pt] \beta\frac{\partial P}{\partial t} + \frac{P}{\eta} &= -\frac{\partial V_x}{\partial x} \end{aligned}\] <p>Note the addition of the new term \(\frac{Pr}{\eta}\) to the left-hand side of the mass balance equation, which could be interpreted physically as accounting for the bulk viscosity of the gas.</p> <p>Equvalently, we could add the time derivative to the diffusion equation</p> \[\begin{aligned} \rho\frac{\partial q}{\partial t} + \frac{q}{D} &= -\frac{\partial C}{\partial x} \\[10pt] \frac{\partial C}{\partial t} &= -\frac{\partial q}{\partial x} \end{aligned}\] <p>In that case, the new term would be \(\rho\frac{\partial q}{\partial t}\), which could be interpreted physically as adding the inertia to the momentum equation for diffusive flux.</p> <p>Note that in 1D the both modifications are equivalent up to renaming the variables. The conceptual difference is that in the former case we add new terms to the vector quantity &#40;diffusive flux \(q\)&#41;, and in the latter case we modify the equation governing the evolution of the scalar quantity &#40;pressure \(P\)&#41;.</p> <p>Let&#39;s eliminate \(V_x\) and \(q\) in both systems to get one governing equation for \(P\) and \(C\), respectively:</p> \[\begin{aligned} \beta\frac{\partial^2 P}{\partial t^2} + \frac{1}{\eta}\frac{\partial P}{\partial t} &= \frac{1}{\rho}\frac{\partial^2 P}{\partial x^2} \\[10pt] \rho\frac{\partial^2 C}{\partial t^2} + \frac{1}{D}\frac{\partial C}{\partial t} &= \frac{\partial^2 C}{\partial x^2} \end{aligned}\] <p>We refer to such equations as the <em>damped wave equations</em>. They combine wave propagation with diffusion, which manifests as wave attenuation, or decay. The damped wave equation is a hyperbolic PDE.</p> <h3 id=implementing_the_damped_wave_equation ><a href="#implementing_the_damped_wave_equation" class=header-anchor >Implementing the damped wave equation</a></h3> <p>In the following, we&#39;ll use the damped wave equation for concentration \(C\) obtained by augmenting the diffusion equation with density \(\rho\).</p> <p>Starting from the existing code implementing time-dependent diffusion, let&#39;s add the intertial term \(\rho\frac{\partial q}{\partial t}\).</p> <p>First step is to add the new physical parameter \(\rho\) to the <code># physics</code> section:</p> <pre><code class=language-julia ># physics
...
œÅ   &#61; 20.0</code></pre> <p>And to change the initial conditions to have more interesting time evolution:</p> <pre><code class=language-julia ># array initialisation
C    &#61; @. exp&#40;-&#40;xc-lx/4&#41;^2&#41;; C_i &#61; copy&#40;C&#41;; C&#91;1&#93; &#61; 1</code></pre> <p>Then we modify the time loop to incorporate the new physics:</p> <pre><code class=language-julia >for it &#61; 1:nt
    #qx         .-&#61; ...
    C&#91;2:end-1&#93; .-&#61; dt.*diff&#40;qx&#41;./dx
    ...
end</code></pre> <p>üëâ Your turn. Try to add the intertial term.</p> <blockquote> <p>Hint: There are two ways of adding the intertial term into the update rule.</p> <ul> <li><p>We could either take the known flux <code>q</code> in <code>q/dc</code> from the previous time step &#40;explicit time integration&#41;, or the unknown flux from the next time step &#40;implicit time integration&#41;.</p> <li><p>Could we treat the flux implicitly without having to solve the linear system?</p> <li><p>What are the benefits of the implicit time integration compared to the explicit one?</p> </ul> </blockquote> <p>If the implementation is correct, we should see this:</p> <center> <video width="80%" autoplay loop controls src="../assets/literate_figures/damped_diffusion_1D.mp4"/> </center> <p>The waves decay, now there is a steady state&#33; üéâ The time it takes to converge, however, doesn&#39;t seem to improve...</p> <p>Now we solve the hyperbolic PDE, and with the implicit flux term treatment, the time step should be now proportional to the grid spacing <code>dx</code> instead of <code>dx^2</code>. Looking at the damped wave equation for \(C\), and recalling the stability condition for wave propagation, we modify the time step, reduce the total number of time steps, and increase the frequency of plotting calls:</p> <pre><code class=language-julia ># numerics
...
nvis &#61; 5
# derived numerics
...
dt   &#61; dx/sqrt&#40;1/œÅ&#41;
nt   &#61; 5nx</code></pre> <p>Re-run the simulation and see the results:</p> <center> <video width="80%" autoplay loop controls src="../assets/literate_figures/damped_diffusion_better_1D.mp4"/> </center> <p>Now, this is much better&#33; We observe that in less time steps, we get a much faster convergence. However, we introduced the new parameter, \(\rho\). Does the solution depend on the value of \(\rho\)?</p> <h2 id=problem_of_finding_the_iteration_parameters ><a href="#problem_of_finding_the_iteration_parameters" class=header-anchor >Problem of finding the iteration parameters</a></h2> <p>üëâ Try changing the new parameter <code>œÅ</code>, increase and decrease it. What happens to the solution?</p> <p>We noticed that depending on the value of the parameter <code>œÅ</code>, the convergence to steady-state can be faster or slower. If <code>œÅ</code> is too small, the process becomes diffusion-dominated, and we&#39;re back to the non-accelerated version. If <code>œÅ</code> is too large, waves decay too slow.</p> <p>If the parameter <code>œÅ</code> has optimal value, the convergence to steady-state could be achieved in the number of time steps proportional to the number of grid points <code>nx</code> and not <code>nx^2</code> as for the parabolic PDE.</p> <h3 id=historical_perspective ><a href="#historical_perspective" class=header-anchor >Historical perspective</a></h3> <p>The idea of accelerating the convergence by increasing the order of PDE dates back to the work by <a href="https://doi.org/10.2307/2002770">Frankel &#40;1950&#41;</a> where he studied the convergence rates of different iterative methods. Frankel noted the analogy between the iteration process and transient physics. In his work, the accelerated method was called the <em>second-order Richardson method</em></p> <p>In this course, we call this and any method that builds upon the analogy to transient physics... the <em>pseudo-transient</em> method.</p> <p>Using this analogy proves useful when studying multi-physics and nonlinear processes. The pseudo-transient method isn&#39;t restricted to solving the Poisson problems, but can be applied to a wide range of problems that are modeled with PDEs.</p> <h2 id=pseudo-transient_method ><a href="#pseudo-transient_method" class=header-anchor >Pseudo-transient method</a></h2> <p>In a pseudo-transient method, we are interested only in a steady-state distributions of the unknown field variables such as concentration, temperature, etc.</p> <p>We consider time steps as iterations in a numerical method. Therefore, we replace the time \(t\) in the equations with <em>pseudo-time</em> \(\tau\), and a time step <code>it</code> with iteration counter <code>iter</code>. When a pseudo-transient method converges, all the pseudo-time derivatives \(\partial/\partial\tau\), \(\partial^2/\partial\tau^2\) etc., vanish.</p> <p>We should be careful when introducing the new pseudo-physical terms into the governing equations. We need to make sure that when iterations converge, i.e., if the pseudo-time derivatives are set to 0, the system of equations is identical to the original steady-state formulation.</p> <p>For example, consider the damped acoustic problem that we introduced in the beggining:</p> \[\begin{aligned} \rho\frac{\partial V_x}{\partial\tau} &= -\frac{\partial P}{\partial x} \\[10pt] \beta\frac{\partial P}{\partial\tau} + \frac{P}{\eta} &= -\frac{\partial V_x}{\partial x} \end{aligned}\] <p>At the steady-state, the second equation reads:</p> \[ \frac{P}{\eta} = -\frac{\partial V_x}{\partial x} \] <p>The velocity divergence is proportional to the pressure. If we wanted to solve the incompressible problem &#40;i.e. the velocty divergence &#61; 0&#41;, and were interested in the velocity distribution, this approach would lead to incorrect results. If we only want to solve the Laplace problem \(\partial^2 P/\partial x^2 = 0\), we could consider \(V_x\) purely as a numerical variable.</p> <p>In other words: only add those new terms to the governing equations that vanish when the iterations converge&#33;</p> <h2 id=dispersion_analysis_of_the_pdes ><a href="#dispersion_analysis_of_the_pdes" class=header-anchor >Dispersion analysis of the PDEs</a></h2> <p>We don&#39;t want to guess the optimal parameter values for every problem. For linear problems with constant coefficients, there is a way to get an exact optimal value for any combination of phyisics and boundary conditions. Analytics is hard, so we&#39;ll consider only the simplest elliptic problem with constant values at boundaries:</p> <p>Let&#39;s try this value:</p> <pre><code class=language-julia >œÅ    &#61; &#40;lx/&#40;dc*2œÄ&#41;&#41;^2</code></pre>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<h1 id=julias_repl_the_package_manager_pkgjl_and_essential_packages ><a href="#julias_repl_the_package_manager_pkgjl_and_essential_packages" class=header-anchor >Julia&#39;s REPL, the Package manager &#40;Pkg.jl&#41;, and essential packages</a></h1>
<h2 id=julia_repl ><a href="#julia_repl" class=header-anchor >Julia REPL</a></h2>
<p><a href="https://docs.julialang.org/en/v1/stdlib/REPL/">https://docs.julialang.org/en/v1/stdlib/REPL/</a></p>
<p><code>julia</code> starts the REPL, run <code>julia --help</code> to see options.</p>
<p>Pretty powerful REPL:</p>
<ul>
<li><p>completion</p>

<li><p>history:</p>
<ul>
<li><p>start typing &#43; up-arrow</p>

<li><p>Ctrl-r</p>

</ul>

<li><p>unicode completion</p>

<li><p>several sub-modes: shell, Pkg, help</p>
<ul>
<li><p>they are displayed with a different prompt</p>

<li><p>shell mode in Windows, try: <code>shell&gt; powershell</code></p>

</ul>

</ul>
<p><strong>Demo</strong></p>
<h2 id=julia_package_manager ><a href="#julia_package_manager" class=header-anchor >Julia Package manager</a></h2>
<p>Docs:</p>
<ul>
<li><p><a href="https://docs.julialang.org/en/v1/stdlib/Pkg/">short</a></p>

<li><p><a href="https://pkgdocs.julialang.org/v1/">detailed</a></p>

</ul>
<p>Powerful package manager:</p>
<ul>
<li><p>installing, updating and removing packages</p>

<li><p>separate environments for separate projects</p>

</ul>
<p><strong>Demo</strong></p>
<p><strong>Take-home</strong>: make a separate Project for each of your projects/assignments&#33;</p>
<h2 id=essential_packages_for_your_global_environment ><a href="#essential_packages_for_your_global_environment" class=header-anchor >Essential packages for your global environment</a></h2>
<p>Packages installed in your global environment are always available, thus useful for utility packages.</p>
<p>I have installed in my global environment:</p>
<ul>
<li><p><a href="https://github.com/timholy/Revise.jl">Revise.jl</a> ‚Äì To load it at startup: <code>mkdir -p ~/.julia/config/ &amp;&amp; echo &quot;using Revise&quot; &gt;&gt; ~/.julia/config/startup.jl</code></p>

<li><p><a href="https://github.com/timholy/Revise.jl">BenchmarkTools.jl</a> ‚Äì Accurate timers for benchmarking, even quick fast running functions</p>

<li><p><a href="https://github.com/JuliaLang/IJulia.jl">IJulia.jl</a> ‚Äì The Julia Jupyter kernel.  Needs to be installed globally.</p>

<li><p><a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a></p>

<li><p><a href="https://github.com/JuliaPlots/Plots.jl">Infiltrator.jl</a> ‚Äì A debugger.  Pretty basic but works well without slowing down program execution &#40;unlike Debugger.jl which has more features&#41;.</p>

<li><p><a href="https://github.com/tkluck/StatProfilerHTML.jl">StatProfilerHTML.jl</a> or <a href="https://github.com/timholy/ProfileView.jl/">ProfileView.jl</a> ‚Äì To be used with the built in <code>Profile</code> module.  Displays nice flame graphs &#40;probably does not work on the GPU&#41;</p>

</ul>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<h1 id=exercises_-_lecture_3 ><a href="#exercises_-_lecture_3" class=header-anchor >Exercises - lecture 3</a></h1>
<div class=warning ><div class=title >‚ö†Ô∏è Warning&#33;</div>
<div class=messg >Starting from this week&#39;s lecture 3, all exercises have to be handed in as monolithic Julia scripts &#40;one code per script&#41; and uploaded to your private &#40;shared&#41; GitHub repository, in a <strong>specific folder for each lecture</strong>. The git commit hash &#40;or SHA&#41; of the final push needs to be uploaded on Moodle &#40;<a href="/homework">more</a>&#41;.</div></div>
<h2 id=exercise_1_-_acoustic_waves_in_2d ><a href="#exercise_1_-_acoustic_waves_in_2d" class=header-anchor >Exercise 1 - <strong>Acoustic waves in 2D</strong></a></h2>
<p>üëâ See <a href="/logistics/#submission">Logistics</a> for submission details.</p>
<p>The goal of this exercise is to:</p>
<ul>
<li><p>Implement 2D wave equation</p>

<li><p>Consolidate the finite-difference discretisation</p>

<li><p>Familiarise with visualisation</p>

</ul>
<p>The goal of this first exercise is to repeat the steps we did in class with the diffusion codes going from the 1D to the 2D implementation.</p>
<p>Starting from the 1D acoustic wave equation we discussed in lecture 3, extend the 1D code to a 2D configuration. Use the same parameters for the \(y\)-direction quantities as the one for the \(x\)-direction.</p>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >Don&#39;t forget to initialise &#40;pre-allocate&#41; all arrays &#40;vectors&#41; needed in the calculations.</div></div>
<h3 id=task_1 ><a href="#task_1" class=header-anchor >Task 1</a></h3>
<p>Create a new Julia script <code>acoustic_2D_v1.jl</code> for this homework. The script should produce a <code>heatmap&#40;&#41;</code> plot that updates upon time steps, with labelled axes and physical time displayed as title.</p>
<p>Use <code>nx &#61; 128</code> and <code>ny &#61; 129</code> grid points.</p>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >During development, having <code>nx ‚â† ny</code> may prevent errors with staggering to occur.</div></div>
<h3 id=task_2 ><a href="#task_2" class=header-anchor >Task 2</a></h3>
<p>Record the pressure at position \((x,y) = (5,7)\) during the entire simulation and report it as a subplot &#40;pressure as function of time&#41;.</p>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >Check out e.g. <a href="https://docs.juliaplots.org/latest/tutorial/#Combining-Multiple-Plots-as-Subplots">here</a> for inspiration about subplots.</div></div>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<hr />
<h2 id=exercise_2_-_acoustic_waves_in_2d_-_v2 ><a href="#exercise_2_-_acoustic_waves_in_2d_-_v2" class=header-anchor >Exercise 2 - <strong>Acoustic waves in 2D - v2</strong></a></h2>
<p>üëâ See <a href="/logistics/#submission">Logistics</a> for submission details.</p>
<p>The goal of this exercise is to:</p>
<ul>
<li><p>Implement 2D wave equation</p>

<li><p>Consolidate the finite-difference discretisation</p>

<li><p>Familiarise with visualisation</p>

</ul>
<p>In this second exercise, you will implement a more concise version of the 2D wave equation.</p>
<p>Starting from the 2D wave equation code from exercise 1, reformulate the physics calculation without the explicit definition of the \(q_x, q_y\) terms; only use velocities \(V_x, V_y\) and pressure \(P\).</p>
<h3 id=task_1__2 ><a href="#task_1__2" class=header-anchor >Task 1</a></h3>
<p>Create a new Julia script <code>acoustic_2D_v2.jl</code> for this homework. The script should produce a <code>heatmap&#40;&#41;</code> plot that updates upon time steps, with labelled axes and physical time displayed as title.</p>
<p>Use <code>nx &#61; 128</code> and <code>ny &#61; 129</code> grid points and the same parameters as for exercise 1.</p>
<h3 id=task_2__2 ><a href="#task_2__2" class=header-anchor >Task 2</a></h3>
<p>Create a 3-panels plot that shows the 2D pressure \(P\) and the velocity \(V_x\) fields, as well as the 1D cross-section of the pressure field at \(Ly/2\).</p>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<hr />
<h2 id=exercise_3_-_acoustic_waves_in_2d_-_v3 ><a href="#exercise_3_-_acoustic_waves_in_2d_-_v3" class=header-anchor >Exercise 3 - <strong>Acoustic waves in 2D - v3</strong></a></h2>
<p>üëâ See <a href="/logistics/#submission">Logistics</a> for submission details.</p>
<p>The goal of this exercise is to:</p>
<ul>
<li><p>Implement 2D wave equation</p>

<li><p>Consolidate the finite-difference discretisation</p>

<li><p>Familiarise with visualisation</p>

</ul>
<p>In this third exercise, implement the second-order wave equation as reported at the <a href="#the_wave_equation">beginning of lecture 3</a>,</p>
\[ \frac{‚àÇ^2P}{‚àÇt^2} = c^2 ‚àá^2 P~, \]
<p>where</p>
<ul>
<li><p>\(P\) is pressure,</p>

<li><p>\(c\) a non-negative real constant, here the speed of sound.</p>

</ul>
<p>Verify that \(c=\sqrt(K/œÅ)\) and add <code>c</code> as new parameter to a <code># Derived physics</code> section in the code.</p>
<p>The challenge here is to implement the second-order time derivative of the pressure \(P\), which expands as</p>
\[  \frac{‚àÇ^2P}{‚àÇt^2} = P^{t+‚àÜt} - 2~P^{t} + P^{t-‚àÜt}~,\]
<p>reason you actually need 3 explicit time integration layer, \(P_\mathrm{new},~P_\mathrm{current},~P_\mathrm{old}\), updating \(P_\mathrm{new}\) as from the two others and using \(P_\mathrm{current}\) in the spatial derivatives.</p>
<p>Also, make sure to initialise all 3 pressure arrays with the same Gaussian initial condition.</p>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >You may need to use 3 arrays for the pressure update, <code>Pold</code>, <code>P</code> and <code>Pnew</code>; in <code>Pold</code> you can store the values at time <code>&#40;it-1&#41;</code>, while you can use the array <code>P</code> for holding current <code>&#40;it&#41;</code> pressure values and finally use <code>Pnew</code> for prediction at <code>&#40;it&#43;1&#41;</code>. Don&#39;t forget to assign the appropriate updates at the end of the time loop.</div></div>
<h3 id=task_1__3 ><a href="#task_1__3" class=header-anchor >Task 1</a></h3>
<p>Create a new Julia script <code>acoustic_2D_v3.jl</code> for this homework. The script should produce a <code>heatmap&#40;&#41;</code> plot that updates upon time steps, with labelled axes and physical time displayed as title.</p>
<p>Use <code>nx &#61; 128</code> and <code>ny &#61; 129</code> grid points and the same parameters as for exercise 1 and 2.</p>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<hr />
<h2 id=exercise_4_-_seismic_p-waves ><a href="#exercise_4_-_seismic_p-waves" class=header-anchor >Exercise 4 - <strong>Seismic P-waves</strong></a></h2>
<p>üëâ See <a href="/logistics/#submission">Logistics</a> for submission details.</p>
<p>The goal of this exercise is to:</p>
<ul>
<li><p>Implement 2D wave equation</p>

<li><p>Record the signal on a synthetic seismic array</p>

<li><p>Train visualisation</p>

</ul>
<p>In this last exercise, you will implement a synthetic wave propagation solver, to resolve seismic pressure &#40;P-&#41;wave propagation in a sandstone. You will deploy an array of synthetic geophones &#40;receivers&#41; and record the seismic signal.</p>
<p>Create a new Julia script <code>acoustic_2D_v4.jl</code> for this homework, starting from the code you developed for <a href="#exercise_2_-_acoustic_waves_in_2d_-_v2">exercise 2</a>.</p>
<p><img src="../assets/literate_figures/wave_ex4_sketch.png" alt=wave-ex4-sketch  /></p>
<h3 id=task_1__4 ><a href="#task_1__4" class=header-anchor >Task 1</a></h3>
<p>Implement the following changes:</p>
<ul>
<li><p>Change the domain extend to \(L_x=1000\) m, \(L_y=500\) m &#40;with origin located in the bottom left corner of the model&#41;</p>

<li><p>For sandstone, set the elastic moduli \(K=40\) GPa and the density \(œÅ=2400\) Kg/m\(^3\)</p>

<li><p>Define a Gaussian function for the source at \(t=0\), with centre location \((x_s, y_s)\) at \(x_s = 200\) and at \(50\) m below the surface. Use a standard deviation of \(5\) m and an amplitude of \(1\) Pa.</p>

<li><p>Run the experiment for a total \(t_\mathrm{tot}=0.2\) sec</p>

<li><p>Set pressure values as <code>P&#91;:,end&#93; .&#61; P&#91;:,end-1&#93;</code> in order to minimise boundary effects on the top boundary</p>

</ul>
<p>You should obtain a similar output for your figure &#40;try saving it as .png from within Julia&#41;</p>
<p><img src="../assets/literate_figures/wave_ex4.png" alt=wave-ex4  /></p>
<h3 id=task_2__3 ><a href="#task_2__3" class=header-anchor >Task 2</a></h3>
<p>In a second step,</p>
<ul>
<li><p>Add 5 monitoring stations located at \(y_\mathrm{monit}\) ~\(20\) m below the ground between \(x=500\) and \(900\) m, distant from each other by \(100\) m.</p>

<li><p>Record and store the pressure in each monitoring station throughout the entire simulation</p>

<li><p>For the first station &#40;located at \(x=500\) m&#41;, find the arrival time for which the pressure \(P > 0.02\) Pa</p>

<li><p>Knowing at which time the wave hit the first station, you can post-process and <strong>report following &#40;as formatted output in the REPL or on a figure&#41;</strong>:</p>
<ul>
<li><p>First wave arrival time &#40;in s&#41; at station \(x_s=500\) m</p>

<li><p>Distance &#40;<code>‚àÜ_dist</code>&#41; the wave travelled</p>

<li><p>\(x\)-location of the seismic source</p>

</ul>

</ul>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<div class=page-foot >
  <div class=copyright >
    <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/"><b>Edit this page on <img class=github-logo  src="https://unpkg.com/ionicons@5.1.2/dist/svg/logo-github.svg"></b></a><br>
    Last modified: September 30, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>  
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>