<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <script src="/libs/lunr/lunr.min.js"></script> <script src="/libs/lunr/lunr_index.js"></script> <script src="/libs/lunr/lunrclient.min.js"></script> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=stylesheet  href="/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/assets/favicon.png"> <title>Lecture 3</title> <style> .content {max-width: 50rem} </style> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <img src="/assets/vaw_logo.png" style="width: 180px; height: auto; display: inline"> <div style="font-weight: margin-bottom: 0.5em"><a href="/"> Fall 2022</a> <span style="opacity: 0.7;">| <a href="http://www.vvz.ethz.ch/Vorlesungsverzeichnis/lerneinheit.view?semkez=2022W&ansicht=KATALOGDATEN&lerneinheitId=162403&lang=en"> ETHZ 101-0250-00</a></span></div> <br> <h1><a href="/">Solving partial differential equations in parallel on GPUs</a></h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by &nbsp; <a href="https://vaw.ethz.ch/en/people/person-detail.MjcwOTYw.TGlzdC8xOTYxLDE1MTczNjI1ODA=.html">Ludovic R√§ss</a>, &nbsp; <a href="https://vaw.ethz.ch/en/personen/person-detail.html?persid=124402">Mauro Werder</a>, &nbsp; <a href="https://www.cscs.ch/about/staff/">Samuel Omlin</a> & <br> <a href="https://vaw.ethz.ch/en/people/person-detail.MzAwMjIy.TGlzdC8xOTYxLDE1MTczNjI1ODA=.html">Ivan Utkin</a> </div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9; margin-bottom: 1.2cm;"> <a class="sidebar-nav-item " href="/"><b>Welcome</b></a> <a class="sidebar-nav-item " href="/logistics/">Logistics</a> <a class="sidebar-nav-item " href="/homework/">Homework</a> <a class="sidebar-nav-item " href="/software_install/">Software install</a> <a class="sidebar-nav-item " href="/extras/">Extras</a> <br> <div class=course-section >Part 1 - Introduction</div> <a class="sidebar-nav-item " href="/lecture1/">Lecture 1 - Why Julia GPU</a> <a class="sidebar-nav-item " href="/lecture2/">Lecture 2 - PDEs & physical processes</a> <a class="sidebar-nav-item active" href="/lecture3/">Lecture 3 - Solving elliptic PDEs</a> <div class=course-section >Part 2 - Solving PDEs on GPUs</div> <a class="sidebar-nav-item " href="/lecture4/">Lecture 4 - Porous convection</a> <a class="sidebar-nav-item " href="/lecture5/">Lecture 5 - Parallel computing</a> <a class="sidebar-nav-item " href="/lecture6/">Lecture 6 - GPU computing & perf</a> <div class=course-section >Part 3 - Multi-GPU computing (projects)</div> <a class="sidebar-nav-item " href="/lecture7/">Lecture 7 - XPU computing</a> <a class="sidebar-nav-item " href="/lecture8/">Lecture 8 - Julia MPI & multi-XPU</a> <a class="sidebar-nav-item " href="/lecture9/">Lecture 9 - Advanced optimisations</a> <div class=course-section >Final Projects</div> <a class="sidebar-nav-item " href="/lecture10/">Lecture 10 - Final projects</a> </nav> <form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder="Enter search term" type=text > <input type=submit  value=Search  formaction="/search/index.html"> </form> <br> <br> </div> </div> <div class="content container"> <div class=franklin-content > <h1 id=lecture_3 ><a href="#lecture_3" class=header-anchor >Lecture 3</a></h1> <blockquote> <p><strong>Agenda</strong><br />üìö Solving elliptic PDEs, 1D to 2D<br />üíª Personal Julia install, Julia&#39;s <code>Project</code> environment, Julia&#39;s package manager<br />üöß Exercises:</p> <ul> <li><p>Damped wave equation in 1D and 2D</p> <li><p>Port 1D codes to 2D</p> </ul> </blockquote> <p><hr /> </p> <p><a id=content  class=anchor ></a> <strong>Content</strong></p> <div class=franklin-toc ><ol><li><a href="#lecture_3">Lecture 3</a><li><a href="#solving_elliptic_pdes">Solving elliptic PDEs</a><ol><li><a href="#accelerating_elliptic_solver_convergence_intuition">Accelerating elliptic solver convergence: intuition</a><li><a href="#problem_of_finding_the_iteration_parameters">Problem of finding the iteration parameters</a><li><a href="#pseudo-transient_method">Pseudo-transient method</a><li><a href="#multi-physics_steady_diffusion-reaction">Multi-physics: steady diffusion-reaction</a><li><a href="#going_2d">Going 2D</a><li><a href="#wrapping-up">Wrapping-up</a></ol><li><a href="#julias_repl_the_package_manager_pkgjl_and_essential_packages">Julia&#39;s REPL, the Package manager &#40;Pkg.jl&#41;, and essential packages</a><ol><li><a href="#julia_repl">Julia REPL</a><li><a href="#julia_package_manager">Julia Package manager</a><li><a href="#essential_packages_for_your_global_environment">Essential packages for your global environment</a></ol><li><a href="#exercises_-_lecture_3">Exercises - lecture 3</a><ol><li><a href="#exercise_1_-_implicit_transient_diffusion_using_dual_timestepping">Exercise 1 - <strong>Implicit transient diffusion using dual timestepping</strong></a><li><a href="#exercise_2_-_operator-splitting_for_advection-diffusion">Exercise 2 - <strong>Operator-splitting for advection-diffusion</strong></a><li><a href="#exercise_3_-_advection-diffusion_in_2d">Exercise 3 - <strong>Advection-diffusion in 2D</strong></a><li><a href="#exercise_4_-_optimal_iteration_parameters_for_pseudo-transient_method">Exercise 4 - <strong>Optimal iteration parameters for pseudo-transient method</strong></a></ol></ol></div> <p><a href="#exercises_-_lecture_3"><em>üëâ get started with exercises</em></a></p> <hr /> <h1 id=solving_elliptic_pdes ><a href="#solving_elliptic_pdes" class=header-anchor >Solving elliptic PDEs</a></h1> <h3 id=the_goal_of_this_lecture_3_is_to_familiarise_or_refresh_with ><a href="#the_goal_of_this_lecture_3_is_to_familiarise_or_refresh_with" class=header-anchor >The goal of this lecture 3 is to familiarise &#40;or refresh&#41; with:</a></h3> <ul> <li><p>The damped wave equation</p> <li><p>Spectral analysis of linear PDEs</p> <li><p>Pseudo-transient method for solving elliptic PDEs</p> <li><p>Spatial discretisation: 1D and 2D</p> </ul> <p>In the previous lecture, we established that the solution to the elliptic PDE could be obtained through integrating in time a corresponding parabolic PDE:</p> \[ \frac{\partial C}{\partial t} - \frac{\partial^2 C}{\partial x^2} = 0 \] <p>and discussed the limitations of this approach for numerical modelling, i.e., the quadratic dependence of the number of time steps on the number of grid points in spatial discretisation.</p> <center> <video width="80%" autoplay loop controls src="../assets/literate_figures/l2_diffusion_1D_steady_state.mp4"/> </center> <h2 id=accelerating_elliptic_solver_convergence_intuition ><a href="#accelerating_elliptic_solver_convergence_intuition" class=header-anchor >Accelerating elliptic solver convergence: intuition</a></h2> <p>In this lecture, we&#39;ll improve the convergence rate of the elliptic solver, and consider the generalisation to higher dimensions</p> <p>Let&#39;s recall the stability conditions for diffusion and acoustic wave propagation:</p> <pre><code class=language-julia >dt &#61; dx^2/dc/2      # diffusion
dt &#61; dx/sqrt&#40;1/Œ≤/œÅ&#41; # acoustic wave propagation</code></pre> <p>We can see that the acceptable time step for an acoustic problem is proportional to the grid spacing <code>dx</code>, and not <code>dx^2</code> as for the diffusion.</p> <p>The number of time steps required for the wave to propagate through the domain is only proportional to the number of grid points <code>nx</code>.</p> <p>Can we use that information to reduce the time required for the elliptic solver to converge?</p> <p>In the solution to the wave equation, the waves do not attenuate with time: <em>there is no steady state&#33;</em></p> <center> <video width="80%" autoplay loop controls src="../assets/literate_figures/l2_acoustic_1D.mp4"/> </center> <h3 id=damped_wave_equation ><a href="#damped_wave_equation" class=header-anchor >Damped wave equation</a></h3> <p>Let&#39;s add diffusive properties to the wave equation by simply combining the physics:</p> \[\begin{aligned} \rho\frac{\partial V_x}{\partial t} &= -\frac{\partial P}{\partial x} \\[10pt] \beta\frac{\partial P}{\partial t} + \frac{P}{\eta} &= -\frac{\partial V_x}{\partial x} \end{aligned}\] <p>Note the addition of the new term \(\frac{P}{\eta}\) to the left-hand side of the mass balance equation, which could be interpreted physically as accounting for the bulk viscosity of the gas.</p> <p>Equvalently, we could add the time derivative to the diffusion equation</p> \[\begin{aligned} \rho\frac{\partial q}{\partial t} + \frac{q}{D} &= -\frac{\partial C}{\partial x} \\[10pt] \frac{\partial C}{\partial t} &= -\frac{\partial q}{\partial x} \end{aligned}\] <p>In that case, the new term would be \(\rho\frac{\partial q}{\partial t}\), which could be interpreted physically as adding the inertia to the momentum equation for diffusive flux.</p> <div class=note ><div class=title >üí° Note</div> <div class=messg >In 1D, both modifications are equivalent up to renaming the variables. The conceptual difference is that in the former case we add new terms to the vector quantity &#40;diffusive flux \(q\)&#41;, and in the latter case we modify the equation governing the evolution of the scalar quantity &#40;pressure \(P\)&#41;.</div></div> <p>Let&#39;s eliminate \(V_x\) and \(q\) in both systems to get one governing equation for \(P\) and \(C\), respectively:</p> \[\begin{aligned} \beta\frac{\partial^2 P}{\partial t^2} + \frac{1}{\eta}\frac{\partial P}{\partial t} &= \frac{1}{\rho}\frac{\partial^2 P}{\partial x^2} \\[10pt] \rho\frac{\partial^2 C}{\partial t^2} + \frac{1}{D}\frac{\partial C}{\partial t} &= \frac{\partial^2 C}{\partial x^2} \end{aligned}\] <p>We refer to such equations as the <em>damped wave equations</em>. They combine wave propagation with diffusion, which manifests as wave attenuation, or decay. The damped wave equation is a hyperbolic PDE.</p> <h3 id=implementing_the_damped_wave_equation ><a href="#implementing_the_damped_wave_equation" class=header-anchor >Implementing the damped wave equation</a></h3> <p>In the following, we&#39;ll use the damped wave equation for concentration \(C\) obtained by augmenting the diffusion equation with density \(\rho\).</p> <p>Starting from the existing code implementing time-dependent diffusion, let&#39;s add the intertial term \(\rho\frac{\partial q}{\partial t}\).</p> <p>üëâ You can use the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/"><code>l2_diffusion_1D.jl</code> script</a> as starting point.</p> <p>First step is to add the new physical parameter \(\rho\) to the <code># physics</code> section:</p> <pre><code class=language-julia ># physics
...
œÅ   &#61; 20.0</code></pre> <p>Then we increase the number of time steps and reduce the frequency of plotting, and modify the initial conditions to have more interesting time evolution:</p> <pre><code class=language-julia ># numerics
nvis &#61; 50
...
# derived numerics
...
nt   &#61; nx^2 √∑ 5
...
# array initialisation
C    &#61; @. 1.0 &#43; exp&#40;-&#40;xc-lx/4&#41;^2&#41; - xc/lx; C_i &#61; copy&#40;C&#41;</code></pre> <p>Then we modify the time loop to incorporate the new physics:</p> <pre><code class=language-julia >for it &#61; 1:nt
    qx         .-&#61; dt./&#40;œÅ*dc &#43; dt&#41;.*&#40;qx &#43; dc.*diff&#40;C&#41;./dx&#41;
    C&#91;2:end-1&#93; .-&#61; dt.*diff&#40;qx&#41;./dx
    ...
end</code></pre> <p>üëâ Your turn. Try to add the inertial term.</p> <blockquote> <p><strong>Hint</strong>: There are two ways of adding the inertial term into the update rule.</p> <ul> <li><p>We could either take the known flux <code>q</code> in <code>q/dc</code> from the previous time step &#40;explicit time integration&#41;, or the unknown flux from the next time step &#40;implicit time integration&#41;.</p> <li><p>Could we treat the flux implicitly without having to solve the linear system?</p> <li><p>What are the benefits of the implicit time integration compared to the explicit one?</p> </ul> </blockquote> <p>If the implementation is correct, we should see something like this:</p> <center> <video width="80%" autoplay loop controls src="../assets/literate_figures/l3_damped_diffusion_1D.mp4"/> </center> <p>The waves decay, now there is a steady state&#33; üéâ The time it takes to converge, however, doesn&#39;t seem to improve...</p> <p>Now we solve the hyperbolic PDE, and with the implicit flux term treatment, the time step should become proportional to the grid spacing <code>dx</code> instead of <code>dx^2</code>.</p> <p>Looking at the damped wave equation for \(C\), and recalling the stability condition for wave propagation, we modify the time step, reduce the total number of time steps, and increase the frequency of plotting calls:</p> <pre><code class=language-julia ># numerics
...
nvis &#61; 5
# derived numerics
...
dt   &#61; dx/sqrt&#40;1/œÅ&#41;
nt   &#61; 5nx</code></pre> <p>Re-run the simulation and see the results:</p> <center> <video width="80%" autoplay loop controls src="../assets/literate_figures/l3_damped_diffusion_better_1D.mp4"/> </center> <p>Now, this is much better&#33; We observe that in less time steps, we get a much faster convergence. However, we introduced the new parameter, \(\rho\). Does the solution depend on the value of \(\rho\)?</p> <h2 id=problem_of_finding_the_iteration_parameters ><a href="#problem_of_finding_the_iteration_parameters" class=header-anchor >Problem of finding the iteration parameters</a></h2> <p>üëâ Try changing the new parameter <code>œÅ</code>, increasing and decreasing it. What happens to the solution?</p> <p>We notice that depending on the value of the parameter <code>œÅ</code>, the convergence to steady-state can be faster or slower. If <code>œÅ</code> is too small, the process becomes diffusion-dominated, and we&#39;re back to the non-accelerated version. If <code>œÅ</code> is too large, waves decay slowly.</p> <p>If the parameter <code>œÅ</code> has optimal value, the convergence to steady-state could be achieved in the number of time steps proportional to the number of grid points <code>nx</code> and not <code>nx^2</code> as for the parabolic PDE.</p> <p>For linear PDEs it is possible to determine the optimal value for <code>œÅ</code> analytically:</p> <pre><code class=language-julia >œÅ    &#61; &#40;lx/&#40;dc*2œÄ&#41;&#41;^2</code></pre>
<p>How does one derive the optimal values for other problems and boundary conditions? Unfortunately, we don&#39;t have time to dive into details in this course...</p>
<p>The idea of accelerating the convergence by increasing the order of PDE dates back to the work by <a href="https://doi.org/10.2307/2002770">Frankel &#40;1950&#41;</a> where he studied the convergence rates of different iterative methods. Frankel noted the analogy between the iteration process and transient physics. In his work, the accelerated method was called the <em>second-order Richardson method</em></p>
<p>üëÄ If interested, <a href="https://gmd.copernicus.org/articles/15/5757/2022/">R√§ss et al. &#40;2022&#41;</a> paper is a good starting point.</p>
<h2 id=pseudo-transient_method ><a href="#pseudo-transient_method" class=header-anchor >Pseudo-transient method</a></h2>
<p>In this course, we call any method that builds upon the analogy to the transient physics the <em>pseudo-transient</em> method.</p>
<p>Using this analogy proves useful when studying multi-physics and nonlinear processes. The pseudo-transient method isn&#39;t restricted to solving the Poisson problems, but can be applied to a wide range of problems that are modelled with PDEs.</p>
<p>In a pseudo-transient method, we are interested only in a steady-state distributions of the unknown field variables such as concentration, temperature, etc.</p>
<p>We consider time steps as iterations in a numerical method. Therefore, we replace the time \(t\) in the equations with <em>pseudo-time</em> \(\tau\), and a time step <code>it</code> with iteration counter <code>iter</code>. When a pseudo-transient method converges, all the pseudo-time derivatives \(\partial/\partial\tau\), \(\partial^2/\partial\tau^2\) etc., vanish.</p>
<div class=warning ><div class=title >‚ö†Ô∏è Warning&#33;</div>
<div class=messg >We should be careful when introducing the new pseudo-physical terms into the governing equations. We need to make sure that when iterations converge, i.e., if the pseudo-time derivatives are set to 0, the system of equations is identical to the original steady-state formulation.</div></div>
<p>For example, consider the damped acoustic problem that we introduced in the beginning:</p>
\[\begin{aligned}
\rho\frac{\partial V_x}{\partial\tau}                 &= -\frac{\partial P}{\partial x} \\[10pt]
\beta\frac{\partial P}{\partial\tau} + \frac{P}{\eta} &= -\frac{\partial V_x}{\partial x}
\end{aligned}\]
<p>At the steady-state, the second equation reads:</p>
\[
\frac{P}{\eta} = -\frac{\partial V_x}{\partial x}
\]
<p>The velocity divergence is proportional to the pressure. If we wanted to solve the incompressible problem &#40;i.e. the velocity divergence &#61; 0&#41;, and were interested in the velocity distribution, this approach would lead to incorrect results. If we only want to solve the Laplace problem \(\partial^2 P/\partial x^2 = 0\), we could consider \(V_x\) purely as a numerical variable.</p>
<p>In other words: only add those new terms to the governing equations that vanish when the iterations converge&#33;</p>
<h3 id=visualising_convergence ><a href="#visualising_convergence" class=header-anchor >Visualising convergence</a></h3>
<p>Let&#39;s modify the code structure of the new elliptic solver. We need to monitor convergence and stop iterations when the error has reached predefined tolerance.</p>
<p>To define the measure of error, we introduce the residual:</p>
\[
r_C = D\frac{\partial^2 \widehat{C}}{\partial x^2}
\]
<p>where \(\widehat{C}\) is the pseudo-transient solution</p>
<p>There are many ways to define the error as the norm of the residual, the most popular ones are the \(L_2\) norm and \(L_\infty\) norm. We will use the \(L_\infty\) norm here:</p>
\[
\|\boldsymbol{r}\|_\infty = \max_i(|r_i|)
\]
<p>Add new parameters to the <code># numerics</code> section of the code:</p>
<pre><code class=language-julia ># numerics
nx      &#61; 200
œµtol    &#61; 1e-8
maxiter &#61; 20nx
ncheck  &#61; ceil&#40;Int,0.25nx&#41;</code></pre>
<p>Here <code>œµtol</code> is the tolerance for the pseudo-transient iterations, <code>maxiter</code> is the maximal number of iterations, that we use now instead of number of time steps <code>nt</code>, and <code>ncheck</code> is the frequency of evaluating the residual and the norm of the residual, which is a costly operation.</p>
<p>We turn the time loop into the iteration loop, add the arrays to store the evolution of the error:</p>
<pre><code class=language-julia ># iteration loop
iter &#61; 1; err &#61; 2œµtol; iter_evo &#61; Float64&#91;&#93;; err_evo &#61; Float64&#91;&#93;
while err &gt;&#61; œµtol &amp;&amp; iter &lt;&#61; maxiter
    qx         .-&#61; ...
    C&#91;2:end-1&#93; .-&#61; ...
    if iter &#37; ncheck &#61;&#61; 0
        err &#61; maximum&#40;abs.&#40;diff&#40;dc.*diff&#40;C&#41;./dx&#41;./dx&#41;&#41;
        push&#33;&#40;iter_evo,iter/nx&#41;; push&#33;&#40;err_evo,err&#41;
        p1 &#61; plot&#40;xc,&#91;C_i,C&#93;;xlims&#61;&#40;0,lx&#41;,ylims&#61;&#40;-0.1,2.0&#41;,
                  xlabel&#61;&quot;lx&quot;,ylabel&#61;&quot;Concentration&quot;,title&#61;&quot;iter/nx&#61;&#36;&#40;round&#40;iter/nx,sigdigits&#61;3&#41;&#41;&quot;&#41;
        p2 &#61; plot&#40;iter_evo,err_evo;xlabel&#61;&quot;iter/nx&quot;,ylabel&#61;&quot;err&quot;,
                  yscale&#61;:log10,grid&#61;true,markershape&#61;:circle,markersize&#61;10&#41;
        display&#40;plot&#40;p1,p2;layout&#61;&#40;2,1&#41;&#41;&#41;
    end
    iter &#43;&#61; 1
end</code></pre>
<p>Note that we save the number of iteration per grid cell <code>iter/nx</code></p>
<p>If the value of pseudo-transient parameter <code>œÅ</code> is optimal, the number of iterations required for convergence should be proportional to <code>nx</code>, thus the <code>iter/nx</code> should be approximately constant.</p>
<p>üëâ Try to check that by changing the resolution <code>nx</code>.</p>
<p><img src="../assets/literate_figures/l3_steady_diffusion.png" alt=steady-diffusion  /></p>
<h2 id=multi-physics_steady_diffusion-reaction ><a href="#multi-physics_steady_diffusion-reaction" class=header-anchor >Multi-physics: steady diffusion-reaction</a></h2>
<p>Let&#39;s implement our first pseudo-transient multi-physics solver by adding chemical reaction:</p>
\[
D\frac{\partial^2 C}{\partial x^2} = \frac{C - C_{eq}}{\xi}
\]
<p>As you might remember from the exercises, characteristic time scales of diffusion and reaction can be related through the non-dimensional Damk√∂hler number \(\mathrm{Da}=l_x^2/D/\xi\).</p>
<p>üëâ Let&#39;s add the new physical parameters and modify the iteration loop:</p>
<pre><code class=language-julia ># physics
...
C_eq    &#61; 0.1
da      &#61; 10.0
Œæ       &#61; lx^2/dc/da
...
# iteration loop
iter &#61; 1; err &#61; 2œµtol; iter_evo &#61; Float64&#91;&#93;; err_evo &#61; Float64&#91;&#93;
while err &gt;&#61; œµtol &amp;&amp; iter &lt;&#61; maxiter
    ...
    C&#91;2:end-1&#93; .-&#61; dœÑ./&#40;1 &#43; dœÑ/Œæ&#41; .*&#40;&#40;C&#91;2:end-1&#93; .- C_eq&#41;./Œæ .&#43; diff&#40;qx&#41;./dx&#41;
    ...
end</code></pre>
<blockquote>
<p><strong>Hint</strong>: don&#39;t forget to modify the residual&#33;</p>
</blockquote>
<p>Run the simulation and see the results: <img src="../assets/literate_figures/l3_steady_diffusion_reaction.png" alt=steady-diffusion-reaction  /></p>
<p>As a final touch, let&#39;s refactor the code and extract the magical constant <code>2œÄ</code> from the definition of numerical density <code>œÅ</code>:</p>
<pre><code class=language-julia >re      &#61; 2œÄ
œÅ       &#61; &#40;lx/&#40;dc*re&#41;&#41;^2</code></pre>
<p>We call this new parameter <code>re</code> due to it&#39;s association to the non-dimensional <a href="https://en.wikipedia.org/wiki/Reynolds_number">Reynolds number</a> relating intertial and dissipative forces into the momentum balance.</p>
<p>Interestingly, the convergence rate of the diffusion-reaction systems could be improved significantly by modifying <code>re</code> to depend on the previously defined Damk√∂hler number <code>da</code>:</p>
<pre><code class=language-julia >re      &#61; œÄ &#43; sqrt&#40;œÄ^2 &#43; da&#41;</code></pre>
<p>üëâ Verify that the number of iterations is indeed lower for the higher values of the Damk√∂hler number.</p>
<h2 id=going_2d ><a href="#going_2d" class=header-anchor >Going 2D</a></h2>
<p>Converting the 1D code to higher dimensions is remarkably easy thanks to the explicit time integration. Firstly, we introduce the domain extent and the number of grid points in the y-direction:</p>
<pre><code class=language-julia ># physics
lx,ly   &#61; 20.0,20.0
...
# numerics
nx,ny   &#61; 100,100</code></pre>
<p>Then, we calculate the grid spacing, grid cell centers locations, and modify the time step to comply with the 2D stability criteria:</p>
<pre><code class=language-julia ># derived numerics
dx,dy   &#61; lx/nx,ly/ny
xc,yc   &#61; LinRange&#40;dx/2,lx-dx/2,nx&#41;,LinRange&#40;dy/2,ly-dy/2,ny&#41;
dœÑ      &#61; dx/sqrt&#40;1/œÅ&#41;/sqrt&#40;2&#41;</code></pre>
<p>We allocate 2D arrays for concentration and fluxes:</p>
<pre><code class=language-julia ># array initialisation
C       &#61; @. 1.0 &#43; exp&#40;-&#40;xc-lx/4&#41;^2-&#40;yc&#39;-ly/4&#41;^2&#41; - xc/lx
qx,qy   &#61; zeros&#40;nx-1,ny&#41;,zeros&#40;nx,ny-1&#41;</code></pre>
<p>and add the physics for the second dimension:</p>
<pre><code class=language-julia >while err &gt;&#61; œµtol &amp;&amp; iter &lt;&#61; maxiter
    qx                 .-&#61; dœÑ./&#40;œÅ &#43; dœÑ/dc&#41;.*&#40;qx./dc .&#43; diff&#40;C,dims&#61;1&#41;./dx&#41;
    qy                 .-&#61; dœÑ./&#40;œÅ &#43; dœÑ/dc&#41;.*&#40;qy./dc .&#43; diff&#40;C,dims&#61;2&#41;./dy&#41;
    C&#91;2:end-1,2:end-1&#93; .-&#61; dœÑ./&#40;1 &#43; dœÑ/Œæ&#41; .*&#40;&#40;C&#91;2:end-1,2:end-1&#93; .- C_eq&#41;./Œæ .&#43; diff&#40;qx&#91;:,2:end-1&#93;,dims&#61;1&#41;./dx .&#43;
                                                                                diff&#40;qy&#91;2:end-1,:&#93;,dims&#61;2&#41;./dy&#41;
    ...
end</code></pre>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >we have to specify the direction for taking the partial derivatives: <code>diff&#40;C,dims&#61;1&#41;./dx</code>, <code>diff&#40;C,dims&#61;2&#41;./dy</code></div></div>
<p>Last thing to fix is the visualisation, as now we want the top-down view of the computational domain:</p>
<pre><code class=language-julia >p1 &#61; heatmap&#40;xc,yc,C&#39;;xlims&#61;&#40;0,lx&#41;,ylims&#61;&#40;0,ly&#41;,clims&#61;&#40;0,1&#41;,aspect_ratio&#61;1,
             xlabel&#61;&quot;lx&quot;,ylabel&#61;&quot;ly&quot;,title&#61;&quot;iter/nx&#61;&#36;&#40;round&#40;iter/nx,sigdigits&#61;3&#41;&#41;&quot;&#41;</code></pre>
<p>Let&#39;s run the simulation:</p>

<center>
  <video width="80%" autoplay loop controls src="../assets/literate_figures/l3_steady_diffusion_reaction_2D.mp4"/>
</center>

<h2 id=wrapping-up ><a href="#wrapping-up" class=header-anchor >Wrapping-up</a></h2>
<ul>
<li><p>Switching from parabolic to hyperbolic PDE allows to approach the steady-state in number of iterations, proportional to the number of grid points</p>

<li><p>Pseudo-transient &#40;PT&#41; method is the matrix-free iterative method to solve elliptic &#40;and other&#41; PDEs by utilising the analogy to transient physics</p>

<li><p>Using the optimal iteration parameters is essential to ensure the fast convergence of the PT method</p>

<li><p>Extending the codes to 2D and 3D is straightforward with explicit time integration</p>

</ul>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<h1 id=julias_repl_the_package_manager_pkgjl_and_essential_packages ><a href="#julias_repl_the_package_manager_pkgjl_and_essential_packages" class=header-anchor >Julia&#39;s REPL, the Package manager &#40;Pkg.jl&#41;, and essential packages</a></h1>
<h2 id=julia_repl ><a href="#julia_repl" class=header-anchor >Julia REPL</a></h2>
<p><a href="https://docs.julialang.org/en/v1/stdlib/REPL/">https://docs.julialang.org/en/v1/stdlib/REPL/</a></p>
<p><code>julia</code> starts the REPL, run <code>julia --help</code> to see options.</p>
<p>Pretty powerful REPL:</p>
<ul>
<li><p>completion</p>

<li><p>history:</p>
<ul>
<li><p>start typing &#43; up-arrow</p>

<li><p>Ctrl-r</p>

</ul>

<li><p>unicode completion</p>

<li><p>several sub-modes: shell, Pkg, help</p>
<ul>
<li><p>they are displayed with a different prompt</p>

<li><p>shell mode in Windows, try: <code>shell&gt; powershell</code></p>

</ul>

</ul>
<p><strong>Demo</strong></p>
<h2 id=julia_package_manager ><a href="#julia_package_manager" class=header-anchor >Julia Package manager</a></h2>
<p>Docs:</p>
<ul>
<li><p><a href="https://docs.julialang.org/en/v1/stdlib/Pkg/">short</a></p>

<li><p><a href="https://pkgdocs.julialang.org/v1/">detailed</a></p>

</ul>
<p>Powerful package manager:</p>
<ul>
<li><p>installing, updating and removing packages</p>

<li><p>separate environments for separate projects</p>

</ul>
<p><strong>Demo</strong></p>
<p><strong>Take-home</strong>: make a separate Project for each of your projects/assignments&#33;</p>
<h2 id=essential_packages_for_your_global_environment ><a href="#essential_packages_for_your_global_environment" class=header-anchor >Essential packages for your global environment</a></h2>
<p>Packages installed in your global environment are always available, thus useful for utility packages.</p>
<p>I have installed in my global environment:</p>
<ul>
<li><p><a href="https://github.com/timholy/Revise.jl">Revise.jl</a> ‚Äì To load it at startup: <code>mkdir -p ~/.julia/config/ &amp;&amp; echo &quot;using Revise&quot; &gt;&gt; ~/.julia/config/startup.jl</code></p>

<li><p><a href="https://github.com/timholy/Revise.jl">BenchmarkTools.jl</a> ‚Äì Accurate timers for benchmarking, even quick fast running functions</p>

<li><p><a href="https://github.com/JuliaLang/IJulia.jl">IJulia.jl</a> ‚Äì The Julia Jupyter kernel.  Needs to be installed globally.</p>

<li><p><a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a></p>

<li><p><a href="https://github.com/JuliaPlots/Plots.jl">Infiltrator.jl</a> ‚Äì A debugger.  Pretty basic but works well without slowing down program execution &#40;unlike Debugger.jl which has more features&#41;.</p>

<li><p><a href="https://github.com/tkluck/StatProfilerHTML.jl">StatProfilerHTML.jl</a> or <a href="https://github.com/timholy/ProfileView.jl/">ProfileView.jl</a> ‚Äì To be used with the built in <code>Profile</code> module.  Displays nice flame graphs &#40;probably does not work on the GPU&#41;</p>

</ul>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<h1 id=exercises_-_lecture_3 ><a href="#exercises_-_lecture_3" class=header-anchor >Exercises - lecture 3</a></h1>
<div class=warning ><div class=title >‚ö†Ô∏è Warning&#33;</div>
<div class=messg >Starting from this week&#39;s lecture 3, all exercises have to be handed in as monolithic Julia scripts &#40;one code per script&#41; and uploaded to your private &#40;shared&#41; GitHub repository, in a <strong>specific folder for each lecture</strong>. The git commit hash &#40;or SHA&#41; of the final push needs to be uploaded on Moodle &#40;<a href="/homework">more</a>&#41;.</div></div>
<h2 id=exercise_1_-_implicit_transient_diffusion_using_dual_timestepping ><a href="#exercise_1_-_implicit_transient_diffusion_using_dual_timestepping" class=header-anchor >Exercise 1 - <strong>Implicit transient diffusion using dual timestepping</strong></a></h2>
<p>üëâ See <a href="/logistics/#submission">Logistics</a> for submission details.</p>
<p>The goal of this exercise is to:</p>
<ul>
<li><p>Solidify the understanding of the pseudo-transient method</p>

<li><p>Implement transient diffusion solver with implicit time integration using pseudo-transient method</p>

<li><p>Grasp the difference between physical time stepping and pseudo-transient iterations</p>

</ul>
<p>In this first exercise, you will modify the diffusion-reaction example to model transient diffusion, but this time including not just the pseudo-time derivative \(\partial/\partial\tau\), but also the physical time derivative \(\partial/\partial t\).</p>
<p>Recall the transient diffusion equation:</p>
\[
D\frac{\partial^2 C}{\partial x^2} = \frac{\partial C}{\partial t}
\]
<p>Let&#39;s discretise only the time derivative using the first-order Euler integration rule:</p>
\[
\frac{\partial C}{\partial t} \approx \frac{C - C_\mathrm{old}}{\mathrm{d}t}
\]
<p>where \(\mathrm{d}t\) is the physical time step, and \(C_\mathrm{old}\) is the concentration at the previous time step. If we discretise the spatial derivatives is a usual way and update \(C\) using the explicit update rule, the maximum value for the time step is restricted by the stability criteria, and is proportional to the grid spacing \(\mathrm{d}x\). However, if we consider the \(C\) to be from the implicit layer of the time integration scheme, we don&#39;t have that restriction anymore and are free to use any time step. The downside is that in this case we have to solve the linear system to get the values at the next time step.</p>
<p>A close look at the equation with the discretised time derivative reveals that this equation is mathematically identical to the diffusion-reaction equation that we already learned how to solve&#33; The value for the concentration at the old time step \(C_\mathrm{old}\) and the physical time step \(\mathrm{d}t\) correspond to the equilibrium concentration \(C_\mathrm{eq}\) and the time scale of reaction, respectively.</p>
<p>At each physical time step the implicit problem could be solved using the PT method. Thus, there are present time derivatives both in physical time and in pseudo-time. This approach is therefore called <em>the dual-time method</em>. The code structure would include the two nested loops, one for the physical time and one for the pseudo-transient iterations:</p>
<pre><code class=language-julia >anim &#61; @animate for it &#61; 1:nt
    C_old .&#61; C
    iter &#61; 1; err &#61; 2œµtol; iter_evo &#61; Float64&#91;&#93;; err_evo &#61; &#91;&#93;
    while err &gt;&#61; œµtol &amp;&amp; iter &lt;&#61; maxiter
        ...
        iter &#43;&#61; 1
    end
    # visualisation
    ...
end
gif&#40;anim,&quot;anim.gif&quot;;fps&#61;2&#41;</code></pre>
<p>üëâ Download the <code>l3_steady_diffusion_reaction_1D.jl</code> script <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/">here</a> if needed &#40;available after the course&#41;.</p>
<h3 id=getting_started ><a href="#getting_started" class=header-anchor >Getting started</a></h3>
<ol>
<li><p>Create a new folder <code>lecture3</code> in your private GitHub repository.</p>

<li><p>Add a <code>README.md</code> to that folder.</p>

<li><p>Add a copy of the <code>l3_steady_diffusion_reaction_1D.jl</code> script we did in class to your exercise folder and rename it <code>implicit_diffusion_1D.jl</code>.</p>

<li><p>Modify that script so that it includes the physical time loop and performs the numerical experiment as follows.</p>

</ol>
<h3 id=task_1 ><a href="#task_1" class=header-anchor >Task 1</a></h3>
<p>As a first task, rename the <code>C_eq</code> to <code>C_old</code> and <code>Œæ</code> to <code>dt</code>. Make <code>C_old</code> an array and initialise it with copy of <code>C</code>. Set the <code>da</code> number equal to <code>da &#61; 1000.0</code>. Add the new parameter <code>nt &#61; 10</code> indicating the number of physical time steps. Wrap the iteration loop in the outer <code>for</code>-loop to make physical time steps. Move the visualisation outside from the iteration loop, so that the plots are only updated once per physical timestep &#40;keeping error checking for iterations&#41;.</p>
<h3 id=task_2 ><a href="#task_2" class=header-anchor >Task 2</a></h3>
<p>Perform the numerical experiment using the developed code. Report your results in a 2-panel gif, plotting a&#41; the spatial distribution of concentration <code>C</code> after <code>nt&#61;10</code> time steps, on top of the plot of the initial concentration distribution, and b&#41; the error as function of iteration/nx. Include the gif in the <code>README.md</code> and provide one or two sentence of description.</p>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >Use the <code>@animate</code> macro as in the provided code snippet to realise a gif of your simulation results. Use <code>&#33;&#91;fig_name&#93;&#40;./&lt;relative-path&gt;/my_fig.png&#41;</code> to insert a figure or animation in the <code>README.md</code>.</div></div>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<hr />
<h2 id=exercise_2_-_operator-splitting_for_advection-diffusion ><a href="#exercise_2_-_operator-splitting_for_advection-diffusion" class=header-anchor >Exercise 2 - <strong>Operator-splitting for advection-diffusion</strong></a></h2>
<p>üëâ See <a href="/logistics/#submission">Logistics</a> for submission details.</p>
<p>The goal of this exercise is to implement the advection-diffusion with implicit timestepping for diffusion. Start from the time-dependent code you developed in Exercise 1. Then add advection step after the iteration loop so that the concentration is advected only once per physical time step.</p>
<h3 id=getting_started__2 ><a href="#getting_started__2" class=header-anchor >Getting started</a></h3>
<ol>
<li><p>Duplicate the file <code>implicit_diffusion_1D.jl</code> in the folder <code>lecture3</code> and name it <code>implicit_advection_diffusion_1D.jl</code>.</p>

<li><p>Modify that script so that it includes the advection step as follows.</p>

</ol>
<h3 id=task_1__2 ><a href="#task_1__2" class=header-anchor >Task 1</a></h3>
<p>Add advection to the implicit diffusion code, using an advection velocity of</p>
<pre><code class=language-julia >vx &#61; 1.0</code></pre>
<p>and use the stability criteria for advection to specify the physical timestep:</p>
<pre><code class=language-julia >dt &#61; dx/abs&#40;vx&#41;</code></pre>
<p>Note that now one doesn&#39;t need to take the minimum between the time steps for diffusion and advection, since the diffusion that is more restrictive is resolved implicitly. Also, we do not consider any change in velocity direction at mid-simulation.</p>
<p>Now the physical timestep <code>dt</code> is defined by advection velocity, so the <code>da</code> number that is needed for calculating the optimal PT parameters, has to be computed from <code>dt</code>:</p>
<pre><code class=language-julia ># derived numerics
dt      &#61; dx/abs&#40;vx&#41;
da      &#61; lx^2/dc/dt
re      &#61; ...
œÅ       &#61; ...
dœÑ      &#61; ...</code></pre>
<p>Report with the figure, plotting a spatial distribution of concentration <code>C</code> after <code>nt&#61;10</code> time steps, on top of the plot of the initial concentration distribution. Add the figure to the <code>README.md</code> file.</p>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<hr />
<h2 id=exercise_3_-_advection-diffusion_in_2d ><a href="#exercise_3_-_advection-diffusion_in_2d" class=header-anchor >Exercise 3 - <strong>Advection-diffusion in 2D</strong></a></h2>
<p>üëâ See <a href="/logistics/#submission">Logistics</a> for submission details.</p>
<p>The goal of this exercise is to</p>
<ul>
<li><p>Extend the advection-diffusion solver with implicit diffusion step from 1D to 2D</p>

<li><p>Implement the upwind advection scheme in 2D</p>

<li><p>Modify the problem configuration</p>

</ul>
<p>Create a code <code>implicit_advection_diffusion_2D.jl</code> for this exercise and add it to the <code>lecture3</code> folder in your private GitHub repo. Report the results of this exercise within a new section in the <code>README</code>.</p>
<h3 id=getting_started__3 ><a href="#getting_started__3" class=header-anchor >Getting started</a></h3>
<ol>
<li><p>Duplicate the the <code>implicit_diffusion_1D.jl</code> code you created in Exercise 2 and name it <code>implicit_advection_diffusion_2D.jl</code>.</p>

<li><p>Extend the 1D calculations to 2D</p>

<li><p>Add advection as in Exercise 2</p>

</ol>
<p>Modify the initial conditions to include following parameters in the <code># physics</code> section:</p>
<pre><code class=language-julia ># physics
lx,ly   &#61; 10.0,10.0
dc      &#61; 1.0
vx      &#61; 10.0
vy      &#61; -10.0</code></pre>
<p>and implement following initial condition</p>
<pre><code class=language-julia ># array initialisation
C       &#61; @. exp&#40;-&#40;xc-lx/4&#41;^2 -&#40;yc&#39;-3ly/4&#41;^2&#41;
C_old   &#61; copy&#40;C&#41;</code></pre>
<p>Choose the time step according to the following &#40;stability&#41; criterion:</p>
<pre><code class=language-julia >dt &#61; min&#40;dx/abs&#40;vx&#41;,dy/abs&#40;vy&#41;&#41;/2</code></pre>
<p>Also make sure to use the following numerical parameters &#40;in number of grid points <code>nx,ny</code>&#41;</p>
<pre><code class=language-julia ># numerics
nx,ny   &#61; 200,201
œµtol    &#61; 1e-8
maxiter &#61; 10nx
ncheck  &#61; ceil&#40;Int,0.02nx&#41;
nt      &#61; 50</code></pre>
<p>Note that the iterative pseudo-timestep limitation should be updated to</p>
<pre><code class=language-julia >dœÑ &#61; min&#40;dx,dy&#41;/sqrt&#40;1/œÅ&#41;/sqrt&#40;2&#41;</code></pre>
<p>for 2D configurations.</p>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >Make sure to update the flux array initialisation and include the flux in the y-direction <code>qy</code> and use now 2D arrays: <code>qx,qy &#61; zeros&#40;nx-1,??&#41;, zeros&#40;??,ny-1&#41;</code>.</div></div>
<h3 id=task_1__3 ><a href="#task_1__3" class=header-anchor >Task 1</a></h3>
<p>Repeat the steps from the Exercise 1 to create the implicit time-dependent diffusion solver but in 2D. <strong>Do not include advection yet.</strong> Pay attention to add information relative to the second dimension whenever it&#39;s needed.</p>
<p>Make a short animation showing the time evolution of the concentration field <code>C</code> during <code>nt &#61; 50</code> physical time steps. The figure should contain 2 subplots, the first displaying the <code>heatmap</code> of the <code>C</code> field and the second the evolution of the by <code>nx</code> normalised iteration count:</p>
<pre><code class=language-julia ># visualisation
p1 &#61; heatmap&#40;xc,yc,C&#39;;xlims&#61;&#40;0,lx&#41;,ylims&#61;&#40;0,ly&#41;,clims&#61;&#40;0,1&#41;,aspect_ratio&#61;1,
                 xlabel&#61;&quot;lx&quot;,ylabel&#61;&quot;ly&quot;,title&#61;&quot;iter/nx&#61;&#36;&#40;round&#40;iter/nx,sigdigits&#61;3&#41;&#41;&quot;&#41;
p2 &#61; plot&#40;iter_evo,err_evo;xlabel&#61;&quot;iter/nx&quot;,ylabel&#61;&quot;err&quot;,
        yscale&#61;:log10,grid&#61;true,markershape&#61;:circle,markersize&#61;10&#41;
display&#40;plot&#40;p1,p2;layout&#61;&#40;2,1&#41;&#41;&#41;</code></pre>
<h3 id=task_2__2 ><a href="#task_2__2" class=header-anchor >Task 2</a></h3>
<p>Include now the advection step in a similar way as in the 1D case from the previous exercise, i.e., adding them after the iteration loop within the time loop. Use advection velocities and parameters listed above, taking care in implementing the &quot;upwind&quot; strategy discussed in Lecture 2.</p>
<p>Make a short animation showing the time evolution of the concentration field <code>C</code> during <code>nt &#61; 50</code> physical time steps using the same figure layout as for Task 1.</p>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<hr />
<h2 id=exercise_4_-_optimal_iteration_parameters_for_pseudo-transient_method ><a href="#exercise_4_-_optimal_iteration_parameters_for_pseudo-transient_method" class=header-anchor >Exercise 4 - <strong>Optimal iteration parameters for pseudo-transient method</strong></a></h2>
<p>üëâ See <a href="/logistics/#submission">Logistics</a> for submission details.</p>
<p>The goal of this exercise is to confirm numerically the optimality of the pseudo-transient parameters for a 1D elliptic solver &#40;e.g., solving steady-state diffusion&#41;.</p>
<p>You will make the systematic study of the convergence rate of the pseudo-transient method, varying the numerical parameter <code>re</code> on a regular grid of values.</p>
<h3 id=getting_started__4 ><a href="#getting_started__4" class=header-anchor >Getting started</a></h3>
<ol>
<li><p>üëâ Download the <code>l3_steady_diffusion_1D.jl</code> script <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/">here</a> if needed &#40;available after the course&#41;.</p>

<li><p>Create a new code <code>steady_diffusion_parametric_1D.jl</code> for this exercise and add it to the <code>lecture3</code> folder in your private GitHub repo.</p>

<li><p>Report the results of this exercise within a new section in the <code>README.md</code>.</p>

</ol>
<h3 id=task_1__4 ><a href="#task_1__4" class=header-anchor >Task 1</a></h3>
<p>Start from the 1D elliptic solver. Add the new variable storing the range of factors to multiply the <code>re</code> parameter with to the <code># numerics</code> section. Add new array to store the number of iterations per grid block for each value of this factor:</p>
<pre><code class=language-julia ># numerics
fact &#61; 0.5:0.1:1.5
conv &#61; zeros&#40;size&#40;fact&#41;&#41;</code></pre>
<p>Wrap the <code># array initialisation</code> and <code># iteration loop</code> sections of the code in a <code>for</code>-loop over indices of <code>fact</code>:</p>
<pre><code class=language-julia >for ifact in eachindex&#40;fact&#41;
    # array initialisation
    ...
    # iteration loop
    while ...
    end
end</code></pre>
<p>Move the definition of <code>œÅ</code> to the beginning of the new loop. Extract the value <code>2œÄ</code> and store in the variable <code>re</code>, multiplying by the corresponding value from <code>fact</code>:</p>
<pre><code class=language-julia >for ifact in eachindex&#40;fact&#41;
    re &#61; 2œÄ*fact&#91;ifact&#93;
    œÅ  &#61; &#40;lx/&#40;dc*re&#41;&#41;^2
    dœÑ &#61; ...
    ...
end</code></pre>
<p>After every elliptic solve, store the <code>iter/nx</code> value in the <code>conv&#91;ifact&#93;</code>. Report the results as a figure, plotting the <code>conv</code> vs <code>fact</code>. You should get a picture like this:</p>
<p><img src="../assets/literate_figures/l3_checkmark.png" alt=checkmark  /></p>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<div class=page-foot >
  <div class=copyright >
    <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/"><b>Edit this page on <img class=github-logo  src="https://unpkg.com/ionicons@5.1.2/dist/svg/logo-github.svg"></b></a><br>
    Last modified: October 22, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>  
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>