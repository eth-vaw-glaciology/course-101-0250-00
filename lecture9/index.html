<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <script src="/libs/lunr/lunr.min.js"></script> <script src="/libs/lunr/lunr_index.js"></script> <script src="/libs/lunr/lunrclient.min.js"></script> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=stylesheet  href="/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/assets/favicon.png"> <title>Lecture 9</title> <style> .content {max-width: 50rem} </style> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <img src="/assets/vaw_logo.png" style="width: 180px; height: auto; display: inline"> <div style="margin-bottom: 0.5em"><a href="/"> Fall 2025</a> <span style="opacity: 0.7;">| <a href=https://www.vorlesungen.ethz.ch/Vorlesungsverzeichnis/lerneinheit.view?semkez=2025W&ansicht=KATALOGDATEN&lerneinheitId=193496&lang=en> ETHZ 101-0250-00</a></span></div> <br> <h1><a href="/">Solving partial differential equations in parallel on GPUs I</a></h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by &nbsp; <a href="https://vaw.ethz.ch/en/people/person-detail.MjcwOTYw.TGlzdC8xOTYxLDE1MTczNjI1ODA=.html">Ludovic R√§ss</a>, &nbsp; <a href="https://vaw.ethz.ch/en/personen/person-detail.html?persid=124402">Mauro Werder</a>, &nbsp; <a href="https://www.cscs.ch/about/staff/">Samuel Omlin</a> & <br> <a href="https://vaw.ethz.ch/en/people/person-detail.MzAwMjIy.TGlzdC8xOTYxLDE1MTczNjI1ODA=.html">Ivan Utkin</a> </div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9; margin-bottom: 1cm;"> <a class="sidebar-nav-item " href="/"><b>Welcome</b></a> <a class="sidebar-nav-item " href="/logistics/">Logistics</a> <a class="sidebar-nav-item " href="/homework/">Homeworks</a> <a class="sidebar-nav-item " href="/software_install/">Software install</a> <a class="sidebar-nav-item " href="/extras/">Extras</a> <br> <div class=course-section >Part 1 ‚Äì Introduction</div> <a class="sidebar-nav-item " href="/lecture1/">Lecture 1 ‚Äì Introduction to Julia</a> <a class="sidebar-nav-item " href="/lecture2/">Lecture 2 ‚Äì PDEs & physical processes</a> <a class="sidebar-nav-item " href="/lecture3/"> Lecture 3 ‚Äì Solving elliptic PDEs</a> <a class="sidebar-nav-item " href="/lecture4/">Lecture 4 ‚Äì Coupled multi-physics</a> <div class=course-section >Part 2 ‚Äì Solving PDEs on GPUs</div> <a class="sidebar-nav-item " href="/lecture5/">Lecture 5 ‚Äì Porous convection</a> <a class="sidebar-nav-item " href="/lecture6/">Lecture 6 ‚Äì Parallel computing</a> <a class="sidebar-nav-item " href="/lecture7/">Lecture 7 ‚Äì GPU computing</a> <a class="sidebar-nav-item " href="/lecture8/">Lecture 8 ‚Äì xPU computing</a> <div class=course-section >Part 3 ‚Äì Multi-GPU computing (projects)</div> <a class="sidebar-nav-item active" href="/lecture9/">Lecture 9 ‚Äì Julia MPI & multi-xPU</a> <a class="sidebar-nav-item " href="/lecture10/">Lecture 10 ‚Äì ImplicitGlobalGrid.jl</a> <a class="sidebar-nav-item " href="/lecture11/">Lecture 11 ‚Äì Multi-xPU & final project</a> <div class="sidebar-nav-item under-construction"> Lecture 12 ‚Äì Advanced optimisations</div> </nav> <form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder="Enter search term" type=text > <input type=submit  value=Search  formaction="/search/index.html"> </form> <br> <br> </div> </div> <div class="content container"> <div class=franklin-content > <h1 id=lecture_9 ><a href="#lecture_9" class=header-anchor >Lecture 9</a></h1> <blockquote> <p><strong>Agenda</strong><br />üìö Distributed multi-xPU computing, MPI<br />üíª Running multi-GPU applications on supercomputers<br />üöß Exercises:</p> <ul> <li><p>Fake-parallelisation</p> <li><p>Julia MPI</p> </ul> </blockquote> <hr /> <p><a id=content  class=anchor ></a> <strong>Content</strong></p> <div class=franklin-toc ><ol><li><a href="#lecture_9">Lecture 9</a><li><a href="#distributed_computing_in_julia">Distributed computing in Julia</a><ol><li><a href="#new_to_distributed_computing">New to distributed computing?</a><li><a href="#fake_parallelisation">Fake parallelisation</a><li><a href="#julia_and_mpi">Julia and MPI</a></ol><li><a href="#exercises_-_lecture_9">Exercises - lecture 9</a><ol><li><a href="#exercise_1_towards_distributed_memory_computing_on_gpus">Exercise 1 ‚Äî <strong>Towards distributed memory computing on GPUs</strong></a></ol></ol></div> <p><a href="#exercises_-_lecture_9"><em>üëâ get started with exercises</em></a></p> <hr /> <h1 id=distributed_computing_in_julia ><a href="#distributed_computing_in_julia" class=header-anchor >Distributed computing in Julia</a></h1> <h3 id=the_goal_of_this_lecture_9 ><a href="#the_goal_of_this_lecture_9" class=header-anchor >The goal of this lecture 9:</a></h3> <ul> <li><p>Distributed computing</p> <ul> <li><p>Fake parallelisation</p> <li><p>Julia MPI &#40;CPU &#43; GPU&#41;</p> </ul> </ul> <h2 id=new_to_distributed_computing ><a href="#new_to_distributed_computing" class=header-anchor >New to distributed computing?</a></h2> <p><em>If this is the case or not - hold-on, we certainly have some good stuff for everyone</em></p> <h3 id=distributed_computing ><a href="#distributed_computing" class=header-anchor >Distributed computing</a></h3> <p>Adds one additional layer of parallelisation:</p> <ul> <li><p>Global problem does no longer &quot;fit&quot; within a single compute node &#40;or GPU&#41;</p> <li><p>Local resources &#40;mainly memory&#41; are finite, e.g.,</p> <ul> <li><p>CPUs: increase the number of cores beyond what a single CPU can offer</p> <li><p>GPUs: overcome the device memory limitation</p> </ul> </ul> <p>Simply said:</p> <p><em>If one CPU or GPU is not sufficient to solve a problem, then use more than one and solve a subset of the global problem on each.</em></p> <p>Distributed &#40;memory&#41; computing permits to take advantage of computing &quot;clusters&quot;, many similar compute nodes interconnected by high-throughput network. That&#39;s also what supercomputers are.</p> <h3 id=parallel_scaling ><a href="#parallel_scaling" class=header-anchor >Parallel scaling</a></h3> <p>So here we go. Let&#39;s assume we want to solve a certain problem, which we will call the &quot;global problem&quot;. This global problem, we split then into several local problems that execute concurrently.</p> <p>Two scaling approaches exist:</p> <ul> <li><p>strong scaling</p> <li><p>weak scaling</p> </ul> <p>Increasing the amount of computing resources to resolve the same global problem would increase parallelism and may result in faster execution &#40;wall-time&#41;. This is called <em><strong>strong scaling</strong></em>: the resources are increased but the global problem size does not change, resulting in an increase in the number of &#40;smaller&#41; local problems that can be solved in parallel.</p> <p>The <em><strong>strong scaling</strong></em> approach is often used when parallelising legacy CPU codes, as increasing the number of parallel local problems can lead to some speed-up, reaching an optimum beyond which additional local processes is no longer be beneficial.</p> <p>However, we won&#39;t follow that path when developing parallel multi-GPU applications from scratch. Why?</p> <p><em>Because GPUs&#39; performance is very sensitive to the local problem size as we experienced when trying to tune the kernel launch parameters &#40;threads, blocks, i.e., the local problem size&#41;.</em></p> <p>When developing multi-GPU applications from scratch, it is likely more suitably to approach distributed parallelism from a <em><strong>weak scaling</strong></em> perspective: defining first the optimal local problem size to resolve on a single GPU and then increasing the number of local problems &#40;and the number of GPUs&#41; until reaching the global problem one originally wants to solve.</p> <h3 id=implicit_global_grid ><a href="#implicit_global_grid" class=header-anchor >Implicit Global Grid</a></h3> <p>We can thus replicate a local problem multiple times in each dimension of the Cartesian space to obtain a global grid, which is therefore defined implicitly. Local problems define each others local boundary conditions by exchanging internal boundary values using intra-node communication &#40;e.g., message passing interface - <a href="https://en.wikipedia.org/wiki/Message_Passing_Interface">MPI</a>&#41;, as depicted on the <a href="https://github.com/eth-cscs/ImplicitGlobalGrid.jl">figure</a> hereafter:</p> <p><img src="../assets/literate_figures/l9_igg.png" alt=IGG  /></p> <h3 id=distributing_computations_-_challenges ><a href="#distributing_computations_-_challenges" class=header-anchor >Distributing computations - challenges</a></h3> <p>Many things could potentially go wrong in distributed computing. However, the ultimate goal &#40;at least for us&#41; is to keep up with <em><strong>parallel efficiency</strong></em>.</p> <p>The parallel efficiency defines as the speed-up divided by the number of processors. The speed-up defines as the execution time using an increasing number of processors normalised by the single processor execution time. We will use the parallel efficiency in a weak scaling configuration.</p> <p>Ideally, the parallel efficiency should stay close to 1 while increasing the number of computing resources proportionally with the global problem size &#40;i.e. keeping the constant local problem sizes&#41;, meaning no time is lost &#40;no overhead&#41; in due to, e.g., inter-process communication, network congestion, congestion of shared filesystem, etc... as shown in the <a href="https://github.com/eth-cscs/ImplicitGlobalGrid.jl">figure</a> hereafter:</p> <p><img src="../assets/literate_figures/l9_par_eff.png" alt="Parallel scaling" /></p> <hr /> <h3 id=lets_get_started ><a href="#lets_get_started" class=header-anchor >Let&#39;s get started</a></h3> <p>We will explore distributed computing with Julia&#39;s MPI wrapper <a href="https://github.com/JuliaParallel/MPI.jl">MPI.jl</a>. This will enable our codes to run on multiple CPUs and GPUs in order to scale on modern multi-CPU/GPU nodes, clusters and supercomputers. In the proposed approach, each MPI process handles one CPU or GPU.</p> <p>We&#39;re going to work out the following steps to tackle distributed parallelisation in this lecture &#40;in 5 steps&#41;:</p> <ul> <li><p><a href="#fake_parallelisation"><strong>Fake parallelisation</strong> as proof-of-concept</a></p> <li><p><a href="#julia_and_mpi"><strong>Julia and MPI</strong></a></p> </ul> <h2 id=fake_parallelisation ><a href="#fake_parallelisation" class=header-anchor >Fake parallelisation</a></h2> <p>As a first step, we will look at the below 1-D diffusion code which solves the linear diffusion equations using a &quot;fake-parallelisation&quot; approach. We split the calculation on two distinct left and right domains, which requires left and right <code>C</code> arrays, <code>CL</code> and <code>CR</code>, respectively.</p> <p>In this &quot;fake parallelisation&quot; code, the computations for the left and right domain are performed sequentially on one process, but they could be computed on two distinct processes if the needed boundary update &#40;often referred to as halo update in literature&#41; was done with MPI.</p> <p><img src="../assets/literate_figures/l9_1D_global_grid.png" alt="1D Global grid" /></p> <p>The idea of this fake parallelisation approach is the following:</p> <pre><code class="julia hljs"><span class=hljs-comment ># Compute physics locally</span>
CL[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>] .= CL[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>] .+ dt*D*diff(diff(CL)/dx)/dx
CR[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>] .= CR[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>] .+ dt*D*diff(diff(CR)/dx)/dx
<span class=hljs-comment ># Update boundaries (MPI)</span>
CL[<span class=hljs-keyword >end</span>] = ...
CR[<span class=hljs-number >1</span>]   = ...
<span class=hljs-comment ># Global picture</span>
C .= [CL[<span class=hljs-number >1</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>]; CR[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>]]</code></pre> <p>We see that a correct boundary update will be the critical part for a successful implementation. In our approach, we need an overlap of 2 cells between <code>CL</code> and <code>CR</code> in order to avoid any wrong computations at the transition between the left and right domains.</p> <h3 id=step_1_fake_parallelisation_with_2_fake_processes ><a href="#step_1_fake_parallelisation_with_2_fake_processes" class=header-anchor >Step 1 &#40;fake parallelisation with 2 fake processes&#41;</a></h3> <p>Run the &quot;fake parallelisation&quot; 1-D diffusion code <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_diffusion_1D_2procs.jl</code></a>, which is missing the boundary updates of the 2 fake processes and describe what you see in the visualisation.</p> <p>Then, add the required boundary update:</p> <pre><code class="julia hljs"><span class=hljs-comment ># Update boundaries (MPI)</span>
CL[<span class=hljs-keyword >end</span>] = ...
CR[<span class=hljs-number >1</span>]   = ...</code></pre> <p>in order make the code work properly and run it again. Note what has changed in the visualisation.</p> <center> <video width="60%" autoplay loop controls src="../assets/literate_figures/l9_diff_1D_2procs.mp4"/> </center> <p>The next step will be to generalise the fake parallelisation with <code>2</code> fake processes to work with <code>n</code> fake processes. The idea of this generalised fake parallelisation approach is the following:</p> <pre><code class="julia hljs"><span class=hljs-keyword >for</span> ip = <span class=hljs-number >1</span>:np <span class=hljs-comment ># compute physics locally</span>
    C[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,ip] .= C[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,ip] .+ dt*D*diff(diff(C[:,ip])/dxg)/dxg
<span class=hljs-keyword >end</span>
<span class=hljs-keyword >for</span> ip = <span class=hljs-number >1</span>:np-<span class=hljs-number >1</span> <span class=hljs-comment ># update boundaries</span>
   <span class=hljs-comment ># ...</span>
<span class=hljs-keyword >end</span>
<span class=hljs-keyword >for</span> ip = <span class=hljs-number >1</span>:np <span class=hljs-comment ># global picture</span>
    i1 = <span class=hljs-number >1</span> + (ip-<span class=hljs-number >1</span>)*(nx-<span class=hljs-number >2</span>)
    Cg[i1:i1+nx-<span class=hljs-number >2</span>] .= C[<span class=hljs-number >1</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,ip]
<span class=hljs-keyword >end</span></code></pre> <p>The array <code>C</code> contains now <code>n</code> local domains where each domain belongs to one fake process, namely the fake process indicated by the second index of <code>C</code> &#40;ip&#41;. The boundary updates are to be adapted accordingly. All the physical calculations happen on the local chunks of the arrays.</p> <p>We only need &quot;global&quot; knowledge in the definition of the initial condition.</p> <p>The previous simple initial conditions can be easily defined without computing any Cartesian coordinates. To define other initial conditions we often need to compute global coordinates.</p> <p>In the code below, which serves to define a Gaussian anomaly in the centre of the domain, Cartesian coordinates can be computed for each cell based on the process ID &#40;<code>ip</code>&#41;, the cell ID &#40;<code>ix</code>&#41;, the array size &#40;<code>nx</code>&#41;, the overlap of the local domains &#40;<code>2</code>&#41; and the grid spacing of the global grid &#40;<code>dxg</code>&#41;; moreover, the origin of the coordinate system can be moved to any position using the global domain length &#40;<code>lx</code>&#41;:</p> <pre><code class="julia hljs"><span class=hljs-comment ># Initial condition</span>
<span class=hljs-keyword >for</span> ip = <span class=hljs-number >1</span>:np
    <span class=hljs-keyword >for</span> ix = <span class=hljs-number >1</span>:nx
        x[ix,ip] = ...
        C[ix,ip] = exp(-x[ix,ip]^<span class=hljs-number >2</span>)
    <span class=hljs-keyword >end</span>
    i1 = <span class=hljs-number >1</span> + (ip-<span class=hljs-number >1</span>)*(nx-<span class=hljs-number >2</span>)
    xt[i1:i1+nx-<span class=hljs-number >2</span>] .= x[<span class=hljs-number >1</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,ip]; <span class=hljs-keyword >if</span> (ip==np) xt[i1+nx-<span class=hljs-number >1</span>] = x[<span class=hljs-keyword >end</span>,ip] <span class=hljs-keyword >end</span>
    Ct[i1:i1+nx-<span class=hljs-number >2</span>] .= C[<span class=hljs-number >1</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,ip]; <span class=hljs-keyword >if</span> (ip==np) Ct[i1+nx-<span class=hljs-number >1</span>] = C[<span class=hljs-keyword >end</span>,ip] <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre> <h3 id=step_2_fake_parallelisation_with_n_fake_processes ><a href="#step_2_fake_parallelisation_with_n_fake_processes" class=header-anchor >Step 2 &#40;fake parallelisation with <code>n</code> fake processes&#41;</a></h3> <p>Modify the initial condition in the 1-D diffusion code <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_diffusion_1D_nprocs.jl</code></a> to a centred <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><msub><mi>L</mi><mi>x</mi></msub><mi mathvariant=normal >/</mi><mn>2</mn><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(L_x/2)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">L</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mord >/</span><span class=mord >2</span><span class=mclose >)</span></span></span></span> Gaussian anomaly.</p> <p>Then run this code which is missing the boundary updates of the <code>n</code> fake processes and describe what you see in the visualisation. Then, add the required boundary update in order make the code work properly and run it again. Note what has changed in the visualisation.</p> <center> <video width="60%" autoplay loop controls src="../assets/literate_figures/l9_diff_1D_nprocs.mp4"/> </center> <h2 id=julia_and_mpi ><a href="#julia_and_mpi" class=header-anchor >Julia and MPI</a></h2> <p>We are now ready to write a code that will truly distribute calculations on different processors using <a href="https://github.com/JuliaParallel/MPI.jl">MPI.jl</a> for inter-process communication.</p> <div class=note ><div class=title >üí° Note</div> <div class=messg >At this point, make sure to have a working Julia MPI environment. Head to <a href="/software_install/#julia_mpi">Julia MPI install</a> to set-up Julia MPI. See <a href="/software_install/#gpu_computing_on_alps">GPU computing on Alps</a> for detailed information on how to run MPI GPU &#40;multi-GPU&#41; applications on Daint.Alps.</div></div> <p>Let us see what are the somewhat minimal requirements that will allow us to write a distributed code in Julia using MPI.jl. We will solve the following linear diffusion physics &#40;see <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_diffusion_1D_mpi.jl</code></a>&#41;:</p> <pre><code class="julia hljs"><span class=hljs-keyword >for</span> it = <span class=hljs-number >1</span>:nt
    qx         .= .-D*diff(C)/dx
    C[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>] .= C[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>] .- dt*diff(qx)/dx
<span class=hljs-keyword >end</span></code></pre> <p>To enable distributed parallelisation, we will do the following steps:</p> <ol> <li><p>Initialise MPI and set up a Cartesian communicator</p> <li><p>Implement a boundary exchange routine</p> <li><p>Create a &quot;global&quot; initial condition</p> <li><p>Finalise MPI</p> </ol> <p>To &#40;1.&#41; initialise MPI and prepare the Cartesian communicator, we do &#40;upon <code>import MPI</code>&#41;:</p> <pre><code class="julia hljs"><span class=hljs-keyword >import</span> MPI

MPI.Init()
dims        = [<span class=hljs-number >0</span>]
comm        = MPI.COMM_WORLD
nprocs      = MPI.Comm_size(comm)
MPI.Dims_create!(nprocs, dims)
comm_cart   = MPI.Cart_create(comm, dims, [<span class=hljs-number >0</span>], <span class=hljs-number >1</span>)
me          = MPI.Comm_rank(comm_cart)
coords      = MPI.Cart_coords(comm_cart)
neighbors_x = MPI.Cart_shift(comm_cart, <span class=hljs-number >0</span>, <span class=hljs-number >1</span>)</code></pre> <p>where <code>me</code> represents the process ID unique to each MPI process &#40;the analogue to <code>ip</code> in the fake parallelisation&#41;.</p> <p>Then, we need to &#40;2.&#41; implement a boundary update routine, which can have the following structure:</p> <pre><code class="julia hljs"><span class=hljs-meta >@views</span> <span class=hljs-keyword >function</span> update_halo!(A, neighbors_x, comm)
    <span class=hljs-comment ># Send to / receive from neighbour 1 (&quot;left neighbor&quot;)</span>
    <span class=hljs-keyword >if</span> neighbors_x[<span class=hljs-number >1</span>] != MPI.PROC_NULL
        sendbuf = ??
        recvbuf = ??
        MPI.Send(??,  neighbors_x[?], <span class=hljs-number >0</span>, comm)
        MPI.Recv!(??, neighbors_x[?], <span class=hljs-number >1</span>, comm)
        A[<span class=hljs-number >1</span>] = ??
    <span class=hljs-keyword >end</span>
    <span class=hljs-comment ># Send to / receive from neighbour 2 (&quot;right neighbor&quot;)</span>
    <span class=hljs-keyword >if</span> neighbors_x[<span class=hljs-number >2</span>] != MPI.PROC_NULL
        sendbuf = ??
        recvbuf = ??
        MPI.Recv!(??, neighbors_x[?], <span class=hljs-number >0</span>, comm)
        MPI.Send(??,  neighbors_x[?], <span class=hljs-number >1</span>, comm)
        A[<span class=hljs-keyword >end</span>] = ??
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span>
<span class=hljs-keyword >end</span></code></pre> <p>Then, we &#40;3.&#41; initialize <code>C</code> with a &quot;global&quot; initial Gaussian anomaly that spans correctly over all local domains. This can be achieved, e.g., as given here:</p> <pre><code class="julia hljs">x0    = coords[<span class=hljs-number >1</span>]*(nx-<span class=hljs-number >2</span>)*dx
xc    = [x0 + ix*dx - dx/<span class=hljs-number >2</span> - <span class=hljs-number >0.5</span>*lx  <span class=hljs-keyword >for</span> ix=<span class=hljs-number >1</span>:nx]
C     = exp.(.-xc.^<span class=hljs-number >2</span>)</code></pre> <p>where <code>x0</code> represents the first global x-coordinate on every process &#40;computed in function of <code>coords</code>&#41; and <code>xc</code> represents the local chunk of the global coordinates on each local process &#40;this is analogue to the initialisation in the fake parallelisation&#41;.</p> <p>Last, we need to &#40;4.&#41; finalise MPI prior to returning from the main function:</p> <pre><code class="julia hljs">MPI.Finalize()</code></pre>
<p>All the above described is found in the code <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_diffusion_1D_mpi.jl</code></a>, except for the boundary updates &#40;see 2.&#41;.</p>
<h3 id=step_3_1-d_parallelisation_with_mpi ><a href="#step_3_1-d_parallelisation_with_mpi" class=header-anchor >Step 3 &#40;1-D parallelisation with MPI&#41;</a></h3>
<p>Run the code <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_diffusion_1D_mpi.jl</code></a> which is still missing the boundary updates three times: with 1, 2 and 4 processes &#40;replacing <code>np</code> by the number of processes&#41;:</p>
<pre><code class="sh hljs">mpiexecjl -n &lt;np&gt; julia --project &lt;my_script.jl&gt;</code></pre>
<p>Visualise the results after each run with the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_vizme1D_mpi.jl</code></a> code &#40;<em><strong>adapt the variable <code>nprocs</code>&#33;</strong></em>&#41;. Describe what you see in the visualisation. Then, add the required boundary update in order make the code work properly and run it again. Note what has changed in the visualisation.</p>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >For the boundary updates, you can use the following approach for the communication with each neighbour: 1&#41; create a <code>sendbuffer</code> and <code>receive</code> buffer, storing the right value in the send buffer; 2&#41; use <code>MPI.Send</code> and <code>MPI.Recv&#33;</code> to send/receive the data; 3&#41; store the received data in the right position in the array.</div></div>
<p>Congratulations&#33; You just did a distributed memory diffusion solver in only 70 lines of code.</p>
<p>Let us now do the same in 2D: there is not much new there, but it may be interesting to work out how boundary update routines can be defined in 2D as one now needs to exchange vectors instead of single values.</p>
<p>üëâ You&#39;ll find a working 1D script in the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/">scripts/l9_scripts</a> folder after the lecture.</p>
<h3 id=step_4_2-d_parallelisation_with_mpi ><a href="#step_4_2-d_parallelisation_with_mpi" class=header-anchor >Step 4 &#40;2-D parallelisation with MPI&#41;</a></h3>
<p>Run the code <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_diffusion_2D_mpi.jl</code></a> which is still missing the boundary updates three times: with 1, 2 and 4 processes.</p>
<p>Visualise the results after each run with the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_vizme2D_mpi.jl</code></a> code &#40;adapt the variable <code>nprocs</code>&#33;&#41;. Describe what you see in the visualisation. Then, add the required boundary update in order make the code work properly and run it again. Note what has changed in the visualisation.</p>
<div class=img-med ><img src="../assets/literate_figures/l10_diff_2D_mpi.png" alt="diffusion 2D MPI" /></div>
<p>The last step is to create a multi-GPU solver out of the above multi-CPU solver. CUDA-aware MPI is of great help in this task, because it allows to directly pass GPU arrays to the MPI functions.</p>
<p>Besides facilitating the programming, it can leverage Remote Direct Memory Access &#40;RDMA&#41; which can be of great benefit in many HPC scenarios.</p>
<h3 id=step_5_multi-gpu ><a href="#step_5_multi-gpu" class=header-anchor >Step 5 &#40;multi-GPU&#41;</a></h3>
<p>Translate the code <code>diffusion_2D_mpi.jl</code> from Step 4 to GPU using GPU array programming. Note what changes were needed to go from CPU to GPU in this distributed solver.</p>
<p>Use a similar approach as implemented in the CPU code to perform the boundary updates. You can use the <code>copyto&#33;</code> function in order to copy the data from the GPU memory into the send buffers &#40;CPU memory&#41; or to copy the receive buffer data &#40;CPU memory&#41; baclk to the GPU array.</p>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >Have a look at the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_hello_mpi_gpu.jl</code></a> code to get an idea on how to select a GPU based on node-local MPI infos.</div></div>
<p>Head to the <a href="#exercises_-_lecture_9">exercise section</a> for further directions on this step which is part of this week&#39;s homework assignments.</p>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >As alternative, one could use the same approach as in the CPU code to perform the boundary updates thanks to CUDA-aware MPI &#40;it allows to pass GPU arrays directly to the MPI functions&#41;. However, this requires MPI being specifically built for that purpose.</div></div>
<p>This completes the introduction to distributed parallelisation with Julia.</p>
<p>Note that high-level Julia packages as for example <a href="https://github.com/eth-cscs/ImplicitGlobalGrid.jl">ImplicitGlobalGrid.jl</a> can render distributed parallelisation with GPU and CPU for HPC a very simple task. We&#39;ll check it out in the next lecture.</p>
<h3 id=wrapping_up ><a href="#wrapping_up" class=header-anchor >Wrapping up</a></h3>
<p>Let&#39;s recall what we learned today about distributed computing in Julia using GPUs:</p>
<ul>
<li><p>We used fake parallelisation to understand the correct boundary exchange procedure.</p>

<li><p>We implemented 1D and 2D diffusion solvers in Julia using MPI for distributed memory parallelisation on both CPUs and GPUs &#40;using blocking communication&#41;.</p>

</ul>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<h1 id=exercises_-_lecture_9 ><a href="#exercises_-_lecture_9" class=header-anchor >Exercises - lecture 9</a></h1>
<div class=warning ><div class=title >‚ö†Ô∏è Warning&#33;</div>
<div class=messg >Exercises have to be handed in and uploaded to your private &#40;shared&#41; GitHub repository, in a <em><strong>newly created <code>lecture9</code></strong></em> folder &#40;and <em><strong>not</strong></em> in the <code>PorousConvection</code> folder&#41;. The git commit hash &#40;or SHA&#41; of the final push needs to be uploaded on Moodle &#40;<a href="/homework">more</a>&#41;.</div></div>
<h2 id=exercise_1_towards_distributed_memory_computing_on_gpus ><a href="#exercise_1_towards_distributed_memory_computing_on_gpus" class=header-anchor >Exercise 1 ‚Äî <strong>Towards distributed memory computing on GPUs</strong></a></h2>
<p>üëâ See <a href="/logistics/#submission">Logistics</a> for submission details.</p>
<p>The goal of this exercise is to:</p>
<ul>
<li><p>Familiarise with distributed computing</p>

<li><p>Learn about MPI on the way</p>

</ul>
<p>In this exercise, you will:</p>
<ul>
<li><p>Finalise the fake parallelisation scripts discussed in lecture 9 &#40;2 procs and <code>n</code> procs&#41;</p>

<li><p>Finalise the 2D Julia MPI script</p>

<li><p>Create a Julia MPI GPU version of the 2D Julia MPI script discussed <a href="#task_5_multi-gpu_homework">here</a></p>

</ul>
<p>Create a new <code>lecture_9</code> folder for this first exercise in your shared private GitHub repository for this week&#39;s exercises.</p>
<h3 id=task_1 ><a href="#task_1" class=header-anchor >Task 1</a></h3>
<p>Finalise the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_diffusion_1D_2procs.jl</code></a> and <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_diffusion_1D_nprocs.jl</code></a> scripts discussed during lecture 9. Make sure to correctly implement the halo update in order to exchange the internal boundaries among the fake parallel processes &#40;left and right and <code>ip</code> in the &quot;2procs&quot; and &quot;nprocs&quot; codes, respectively&#41;. See <a href="#fake_parallelisation">here</a> for details.</p>
<p>Report in two separate figures the final distribution of concentration <code>C</code> for both fake parallel codes. Include these figure in a first section of your lecture&#39;s 9 <code>README.md</code> adding a description sentence to each.</p>
<h3 id=task_2 ><a href="#task_2" class=header-anchor >Task 2</a></h3>
<p>Finalise the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_diffusion_2D_mpi.jl</code></a> script discussed during lecture 9. In particular, finalise the <code>update_halo</code> functions to allow for correct internal boundary exchange among the distributed parallel MPI processes. Add the final code to your GitHub lecture 9 folder.</p>
<p>For each of the &#40;4&#41; neighbour exchanges:</p>
<ol>
<li><p>Start by defining a sendbuffer <code>sendbuf</code> to hold the vector you need to send</p>

<li><p>Initialise a receive buffer <code>recvbuf</code> to later hold the vector received from the corresponding neighbouring process</p>

<li><p>Use <code>MPI.Send</code> and <code>MPI.Recv&#33;</code> functions to perform the boundary exchange</p>

<li><p>Assign the values within the receive buffer to the corresponding row or column of the array <code>A</code></p>

</ol>
<div class=note ><div class=title >üí° Note</div>
<div class=messg >Apply similar overlap and halo update as in the fake parallelisation examples. Look-up <a href="https://juliaparallel.github.io/MPI.jl/latest/pointtopoint/#MPI.Send">MPI.Send</a> and <a href="https://juliaparallel.github.io/MPI.jl/latest/pointtopoint/#MPI.Recv&#33;">MPI.recv&#33;</a> for further details.</div></div>
<p>In a new section of your lecture&#39;s 9 <code>README.md</code>, add a .gif animation showing the diffusion of the quantity <code>C</code>, <strong>running on 4 MPI processes</strong>, for the physical and numerical parameters suggested in the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/l9_diffusion_2D_mpi.jl">initial file</a>. Add a short description of the results and provide the command used to launch the script in the <code>README.md</code> as well.</p>
<h3 id=task_3 ><a href="#task_3" class=header-anchor >Task 3</a></h3>
<p>Create a multi-GPU implementation of the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_diffusion_2D_mpi.jl</code></a> script as suggested <a href="#task_5_multi-gpu_homework">here</a>. To this end, create a new script <code>l9_diffusion_2D_mpi_gpu.jl</code> that you will upload to your lecture 9 GitHub repository upon completion.</p>
<p>Translate the <code>l9_diffusion_2D_mpi.jl</code> code from exercise 1 &#40;task 3&#41; to GPU using GPU array programming. You can use a similar approach as in the CPU code to perform the boundary updates. You should use <code>copyto&#33;</code> function in order to copy the data from the GPU memory into the send buffers &#40;CPU memory&#41; or to copy the receive buffer data to the GPU array.</p>
<p>The steps to realise this task summarise as following:</p>
<ol>
<li><p>Select the GPU based on node-local MPI infos &#40;see the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/"><code>l9_hello_mpi_gpu.jl</code></a> code to get started.&#41;</p>

<li><p>Use GPU array initialisation &#40;<code>CUDA.zeros</code>, <code>CuArray&#40;&#41;</code>, ...&#41;</p>

<li><p>Gather the GPU arrays back on the host memory for visualisation or saving &#40;using <code>Array&#40;&#41;</code>&#41;</p>

<li><p>Modify the <code>update_halo</code> function; use <code>copyto&#33;</code> to copy device data to the host into the send buffer or to copy host data to the device from the receive buffer</p>

</ol>
<p>In a new &#40;3rd&#41; section of your lecture&#39;s 9 <code>README.md</code>, add .gif animation showing the diffusion of the quantity <code>C</code>, <strong>running on 4 GPUs &#40;MPI processes&#41;</strong>, for the physical and numerical parameters suggested in the <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/blob/main/scripts/l9_scripts/l9_diffusion_2D_mpi.jl">initial file</a>. Add a short description of the results and provide the command used to launch the script in the <code>README.md</code> as well. Note what changes were needed to go from CPU to GPU in this distributed solver.</p>

<p><a href="#content">‚§¥ <em><strong>back to Content</strong></em></a></p>
<div class=page-foot >
  <div class=copyright >
    <a href="https://github.com/eth-vaw-glaciology/course-101-0250-00/"><b>Edit this page on <img class=github-logo  src="https://unpkg.com/ionicons@5.1.2/dist/svg/logo-github.svg"></b></a><br>
    Last modified: December 02, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>